// Package dip provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package dip

import (
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyHeaderScopes = "ApiKeyHeader.Scopes"
	ApiKeyQueryScopes  = "ApiKeyQuery.Scopes"
)

// Defines values for FundstelleDokumentart.
const (
	FundstelleDokumentartDrucksache      FundstelleDokumentart = "Drucksache"
	FundstelleDokumentartPlenarprotokoll FundstelleDokumentart = "Plenarprotokoll"
)

// Defines values for PlenarprotokollDokumentart.
const (
	PlenarprotokollDokumentartPlenarprotokoll PlenarprotokollDokumentart = "Plenarprotokoll"
)

// Defines values for PlenarprotokollTyp.
const (
	PlenarprotokollTypDokument PlenarprotokollTyp = "Dokument"
)

// Defines values for PlenarprotokollTextDokumentart.
const (
	PlenarprotokollTextDokumentartPlenarprotokoll PlenarprotokollTextDokumentart = "Plenarprotokoll"
)

// Defines values for PlenarprotokollTextTyp.
const (
	PlenarprotokollTextTypDokument PlenarprotokollTextTyp = "Dokument"
)

// Defines values for Quadrant.
const (
	A Quadrant = "A"
	B Quadrant = "B"
	C Quadrant = "C"
	D Quadrant = "D"
)

// Defines values for Zuordnung.
const (
	BR Zuordnung = "BR"
	BT Zuordnung = "BT"
	BV Zuordnung = "BV"
	EK Zuordnung = "EK"
)

// Defines values for Format.
const (
	FormatJson Format = "json"
	FormatXml  Format = "xml"
)

// Defines values for GetPlenarprotokollListParamsFormat.
const (
	GetPlenarprotokollListParamsFormatJson GetPlenarprotokollListParamsFormat = "json"
	GetPlenarprotokollListParamsFormatXml  GetPlenarprotokollListParamsFormat = "xml"
)

// Defines values for GetPlenarprotokollTextListParamsFormat.
const (
	GetPlenarprotokollTextListParamsFormatJson GetPlenarprotokollTextListParamsFormat = "json"
	GetPlenarprotokollTextListParamsFormatXml  GetPlenarprotokollTextListParamsFormat = "xml"
)

// Defines values for GetPlenarprotokollTextParamsFormat.
const (
	GetPlenarprotokollTextParamsFormatJson GetPlenarprotokollTextParamsFormat = "json"
	GetPlenarprotokollTextParamsFormatXml  GetPlenarprotokollTextParamsFormat = "xml"
)

// Defines values for GetPlenarprotokollParamsFormat.
const (
	Json GetPlenarprotokollParamsFormat = "json"
	Xml  GetPlenarprotokollParamsFormat = "xml"
)

// Datum Liefert das Datum eines Dokuments (Drucksache oder Protokoll).
type Datum = openapi_types.Date

// DokumentTextBase Liefert zusätzlich zu den Metadaten den Volltext eines Dokuments.
type DokumentTextBase struct {
	// Text Volltext des Dokuments
	//
	// Das Beispiel enthält einen gekürzten Auszug einer Drucksache.
	Text *string `json:"text,omitempty"`
}

// Fundstelle Liefert im Vorgangsablauf das zu einem Vorgangsschritt gehörende Dokument (Drucksache oder Protokoll).
//
// Beispiel: „BT-Drucksache 19/1 (Antrag Fraktion der CDU/CSU)“ oder beim Vorgangsschritt Beratung „BT-Plenarprotokoll 19/1, S. 4C-12A“.
type Fundstelle struct {
	// Anfangsquadrant Teil der Fundstelle eines Plenarprotokolls. Jede Seite im Plenarprotokoll ist in vier gleich große Viertel unterteilt (Quadranten) mit den Bezeichnungen A, B, C, D.
	Anfangsquadrant *Quadrant             `json:"anfangsquadrant,omitempty"`
	Anfangsseite    *int                  `json:"anfangsseite,omitempty"`
	Anlagen         *string               `json:"anlagen,omitempty"`
	Datum           openapi_types.Date    `json:"datum"`
	Dokumentart     FundstelleDokumentart `json:"dokumentart"`
	Dokumentnummer  string                `json:"dokumentnummer"`
	Drucksachetyp   *string               `json:"drucksachetyp,omitempty"`

	// Endquadrant Teil der Fundstelle eines Plenarprotokolls. Jede Seite im Plenarprotokoll ist in vier gleich große Viertel unterteilt (Quadranten) mit den Bezeichnungen A, B, C, D.
	Endquadrant *Quadrant `json:"endquadrant,omitempty"`
	Endseite    *int      `json:"endseite,omitempty"`
	FrageNummer *string   `json:"frage_nummer,omitempty"`

	// Herausgeber Jeder Vorgangsschritt ist entweder dem Bundestag (BT), dem Bundesrat (BR), der Bundesversammlung (BV) oder der Europakammer (EK) zugeordnet. Über die Zuordnung lassen sich bspw. Rechtsverordnungen herausfiltern, an denen der Bundestag beteiligt / nicht beteiligt war.
	Herausgeber Zuordnung `json:"herausgeber"`

	// Id ID einer Drucksache oder eines Plenarprotokolls
	Id           string              `json:"id"`
	PdfUrl       *string             `json:"pdf_url,omitempty"`
	Seite        *string             `json:"seite,omitempty"`
	Top          *int32              `json:"top,omitempty"`
	TopZusatz    *string             `json:"top_zusatz,omitempty"`
	Urheber      []string            `json:"urheber"`
	Verteildatum *openapi_types.Date `json:"verteildatum,omitempty"`
}

// FundstelleDokumentart defines model for Fundstelle.Dokumentart.
type FundstelleDokumentart string

// ListResponseBase defines model for ListResponseBase.
type ListResponseBase struct {
	Cursor   string `json:"cursor"`
	NumFound int32  `json:"numFound"`
}

// Plenarprotokoll Liefert Metadaten zu einem Plenarprotokoll.
type Plenarprotokoll struct {
	// Aktualisiert Letzte Aktualisierung der Entität
	Aktualisiert   time.Time                  `json:"aktualisiert"`
	Datum          openapi_types.Date         `json:"datum"`
	Dokumentart    PlenarprotokollDokumentart `json:"dokumentart"`
	Dokumentnummer string                     `json:"dokumentnummer"`

	// Fundstelle Liefert im Vorgangsablauf das zu einem Vorgangsschritt gehörende Dokument (Drucksache oder Protokoll).
	//
	// Beispiel: „BT-Drucksache 19/1 (Antrag Fraktion der CDU/CSU)“ oder beim Vorgangsschritt Beratung „BT-Plenarprotokoll 19/1, S. 4C-12A“.
	Fundstelle Fundstelle `json:"fundstelle"`

	// Herausgeber Jeder Vorgangsschritt ist entweder dem Bundestag (BT), dem Bundesrat (BR), der Bundesversammlung (BV) oder der Europakammer (EK) zugeordnet. Über die Zuordnung lassen sich bspw. Rechtsverordnungen herausfiltern, an denen der Bundestag beteiligt / nicht beteiligt war.
	Herausgeber Zuordnung `json:"herausgeber"`
	Id          string    `json:"id"`

	// PdfHash MD5-Prüfsumme der PDF-Datei
	PdfHash           *string            `json:"pdf_hash,omitempty"`
	Sitzungsbemerkung *string            `json:"sitzungsbemerkung,omitempty"`
	Titel             string             `json:"titel"`
	Typ               PlenarprotokollTyp `json:"typ"`

	// Vorgangsbezug Zusammenfassung der ersten 4 zugehörigen Vorgänge
	Vorgangsbezug *[]Vorgangsbezug `json:"vorgangsbezug,omitempty"`

	// VorgangsbezugAnzahl Gesamtzahl der zugehörigen Vorgänge
	VorgangsbezugAnzahl int32  `json:"vorgangsbezug_anzahl"`
	Wahlperiode         *int32 `json:"wahlperiode,omitempty"`
}

// PlenarprotokollDokumentart defines model for Plenarprotokoll.Dokumentart.
type PlenarprotokollDokumentart string

// PlenarprotokollTyp defines model for Plenarprotokoll.Typ.
type PlenarprotokollTyp string

// PlenarprotokollListResponse defines model for PlenarprotokollListResponse.
type PlenarprotokollListResponse struct {
	Cursor    string            `json:"cursor"`
	Documents []Plenarprotokoll `json:"documents"`
	NumFound  int32             `json:"numFound"`
}

// PlenarprotokollText defines model for PlenarprotokollText.
type PlenarprotokollText struct {
	// Aktualisiert Letzte Aktualisierung der Entität
	Aktualisiert   time.Time                      `json:"aktualisiert"`
	Datum          openapi_types.Date             `json:"datum"`
	Dokumentart    PlenarprotokollTextDokumentart `json:"dokumentart"`
	Dokumentnummer string                         `json:"dokumentnummer"`

	// Fundstelle Liefert im Vorgangsablauf das zu einem Vorgangsschritt gehörende Dokument (Drucksache oder Protokoll).
	//
	// Beispiel: „BT-Drucksache 19/1 (Antrag Fraktion der CDU/CSU)“ oder beim Vorgangsschritt Beratung „BT-Plenarprotokoll 19/1, S. 4C-12A“.
	Fundstelle Fundstelle `json:"fundstelle"`

	// Herausgeber Jeder Vorgangsschritt ist entweder dem Bundestag (BT), dem Bundesrat (BR), der Bundesversammlung (BV) oder der Europakammer (EK) zugeordnet. Über die Zuordnung lassen sich bspw. Rechtsverordnungen herausfiltern, an denen der Bundestag beteiligt / nicht beteiligt war.
	Herausgeber Zuordnung `json:"herausgeber"`
	Id          string    `json:"id"`

	// PdfHash MD5-Prüfsumme der PDF-Datei
	PdfHash           *string `json:"pdf_hash,omitempty"`
	Sitzungsbemerkung *string `json:"sitzungsbemerkung,omitempty"`

	// Text Volltext des Dokuments
	//
	// Das Beispiel enthält einen gekürzten Auszug einer Drucksache.
	Text  *string                `json:"text,omitempty"`
	Titel string                 `json:"titel"`
	Typ   PlenarprotokollTextTyp `json:"typ"`

	// Vorgangsbezug Zusammenfassung der ersten 4 zugehörigen Vorgänge
	Vorgangsbezug *[]Vorgangsbezug `json:"vorgangsbezug,omitempty"`

	// VorgangsbezugAnzahl Gesamtzahl der zugehörigen Vorgänge
	VorgangsbezugAnzahl int32  `json:"vorgangsbezug_anzahl"`
	Wahlperiode         *int32 `json:"wahlperiode,omitempty"`
}

// PlenarprotokollTextDokumentart defines model for PlenarprotokollText.Dokumentart.
type PlenarprotokollTextDokumentart string

// PlenarprotokollTextTyp defines model for PlenarprotokollText.Typ.
type PlenarprotokollTextTyp string

// PlenarprotokollTextListResponse defines model for PlenarprotokollTextListResponse.
type PlenarprotokollTextListResponse struct {
	Cursor    string                `json:"cursor"`
	Documents []PlenarprotokollText `json:"documents"`
	NumFound  int32                 `json:"numFound"`
}

// Quadrant Teil der Fundstelle eines Plenarprotokolls. Jede Seite im Plenarprotokoll ist in vier gleich große Viertel unterteilt (Quadranten) mit den Bezeichnungen A, B, C, D.
type Quadrant string

// Vorgangsbezug Liefert ID, Titel und Vorgangstyp eines Vorgangs, der mit der Drucksache oder dem Plenarprotokoll verbunden ist.
type Vorgangsbezug struct {
	// Id ID eines verknüpften Vorgangs
	Id          string `json:"id"`
	Titel       string `json:"titel"`
	Vorgangstyp string `json:"vorgangstyp"`
}

// Zuordnung Jeder Vorgangsschritt ist entweder dem Bundestag (BT), dem Bundesrat (BR), der Bundesversammlung (BV) oder der Europakammer (EK) zugeordnet. Über die Zuordnung lassen sich bspw. Rechtsverordnungen herausfiltern, an denen der Bundestag beteiligt / nicht beteiligt war.
type Zuordnung string

// AktualisiertEndFilter defines model for AktualisiertEndFilter.
type AktualisiertEndFilter = time.Time

// AktualisiertStartFilter defines model for AktualisiertStartFilter.
type AktualisiertStartFilter = time.Time

// Cursor defines model for Cursor.
type Cursor = string

// DatumEndFilter Liefert das Datum eines Dokuments (Drucksache oder Protokoll).
type DatumEndFilter = Datum

// DatumStartFilter Liefert das Datum eines Dokuments (Drucksache oder Protokoll).
type DatumStartFilter = Datum

// DokumentnummerFilter defines model for DokumentnummerFilter.
type DokumentnummerFilter = []string

// Format defines model for Format.
type Format string

// Id defines model for Id.
type Id = int

// IdFilter defines model for IdFilter.
type IdFilter = []int

// VorgangstypFilter defines model for VorgangstypFilter.
type VorgangstypFilter = []string

// VorgangstypNotationFilter defines model for VorgangstypNotationFilter.
type VorgangstypNotationFilter = []int

// WahlperiodeFilter defines model for WahlperiodeFilter.
type WahlperiodeFilter = []int

// ZuordnungFilter Jeder Vorgangsschritt ist entweder dem Bundestag (BT), dem Bundesrat (BR), der Bundesversammlung (BV) oder der Europakammer (EK) zugeordnet. Über die Zuordnung lassen sich bspw. Rechtsverordnungen herausfiltern, an denen der Bundestag beteiligt / nicht beteiligt war.
type ZuordnungFilter = Zuordnung

// BadRequestResponse defines model for BadRequestResponse.
type BadRequestResponse struct {
	Code    BadRequestResponseCode `json:"code"`
	Message string                 `json:"message"`
}

// NotFoundResponse defines model for NotFoundResponse.
type NotFoundResponse struct {
	Code    NotFoundResponseCode `json:"code"`
	Message string               `json:"message"`
}

// UnauthorizedResponse defines model for UnauthorizedResponse.
type UnauthorizedResponse struct {
	Code    UnauthorizedResponseCode    `json:"code"`
	Message UnauthorizedResponseMessage `json:"message"`
}

// GetPlenarprotokollListParams defines parameters for GetPlenarprotokollList.
type GetPlenarprotokollListParams struct {
	// FAktualisiertStart Frühestes Aktualisierungsdatum der Entität
	//
	// Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.
	FAktualisiertStart *AktualisiertStartFilter `form:"f.aktualisiert.start,omitempty" json:"f.aktualisiert.start,omitempty"`

	// FAktualisiertEnd Spätestes Aktualisierungsdatum der Entität
	//
	// Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.
	FAktualisiertEnd *AktualisiertEndFilter `form:"f.aktualisiert.end,omitempty" json:"f.aktualisiert.end,omitempty"`

	// FDatumStart Frühestes Datum der Entität
	//
	// Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.
	FDatumStart *DatumStartFilter `form:"f.datum.start,omitempty" json:"f.datum.start,omitempty"`

	// FDatumEnd Spätestes Datum der Entität
	//
	// Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.
	FDatumEnd *DatumEndFilter `form:"f.datum.end,omitempty" json:"f.datum.end,omitempty"`

	// FDokumentnummer Dokumentnummer einer Drucksache oder eines Plenarprotokolls
	//
	// Selektiert alle Entitäten, die mit der angegebenen Dokumentnummer verknüpft sind.
	// Kann wiederholt werden, um mehrere Dokumentnummern zu selektieren. Hinterlegt ist eine ODER-Suche.
	FDokumentnummer *DokumentnummerFilter `form:"f.dokumentnummer,omitempty" json:"f.dokumentnummer,omitempty"`

	// FId ID der Entität
	//
	// Kann wiederholt werden, um mehrere Entitäten zu selektieren.
	FId *IdFilter `form:"f.id,omitempty" json:"f.id,omitempty"`

	// FVorgangstyp Vorgangstyp
	//
	// Selektiert alle Entitäten, die dem angegebenen Vorgangstyp zugeordnet sind.
	// Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.
	FVorgangstyp *VorgangstypFilter `form:"f.vorgangstyp,omitempty" json:"f.vorgangstyp,omitempty"`

	// FVorgangstypNotation Vorgangstyp-Notation
	//
	// Selektiert alle Entitäten, die der angegebenen Vorgangstyp-Notation zugeordnet sind.
	// Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.
	FVorgangstypNotation *VorgangstypNotationFilter `form:"f.vorgangstyp_notation,omitempty" json:"f.vorgangstyp_notation,omitempty"`

	// FWahlperiode Nummer der Wahlperiode
	//
	// Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind.
	// Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.
	FWahlperiode *WahlperiodeFilter `form:"f.wahlperiode,omitempty" json:"f.wahlperiode,omitempty"`

	// FZuordnung Zuordnung der Entität zum Bundestag, Bundesrat, Bundesversammlung oder Europakammer
	FZuordnung *ZuordnungFilter `form:"f.zuordnung,omitempty" json:"f.zuordnung,omitempty"`

	// Cursor Position des Cursors zur Anfrage weiterer Entitäten
	//
	// Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden.
	// Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird.
	// Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.
	Cursor *Cursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML.
	Format *GetPlenarprotokollListParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPlenarprotokollListParamsFormat defines parameters for GetPlenarprotokollList.
type GetPlenarprotokollListParamsFormat string

// GetPlenarprotokollTextListParams defines parameters for GetPlenarprotokollTextList.
type GetPlenarprotokollTextListParams struct {
	// FAktualisiertStart Frühestes Aktualisierungsdatum der Entität
	//
	// Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.
	FAktualisiertStart *AktualisiertStartFilter `form:"f.aktualisiert.start,omitempty" json:"f.aktualisiert.start,omitempty"`

	// FAktualisiertEnd Spätestes Aktualisierungsdatum der Entität
	//
	// Selektiert Entitäten in einem Datumsbereich basierend auf dem letzten Aktualisierungsdatum.
	FAktualisiertEnd *AktualisiertEndFilter `form:"f.aktualisiert.end,omitempty" json:"f.aktualisiert.end,omitempty"`

	// FDatumStart Frühestes Datum der Entität
	//
	// Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.
	FDatumStart *DatumStartFilter `form:"f.datum.start,omitempty" json:"f.datum.start,omitempty"`

	// FDatumEnd Spätestes Datum der Entität
	//
	// Selektiert Entitäten in einem Datumsbereich basierend auf dem Dokumentdatum. Für Vorgänge und Personen wird der Datumsbereich aller zugehörigen Dokumente herangezogen.
	FDatumEnd *DatumEndFilter `form:"f.datum.end,omitempty" json:"f.datum.end,omitempty"`

	// FDokumentnummer Dokumentnummer einer Drucksache oder eines Plenarprotokolls
	//
	// Selektiert alle Entitäten, die mit der angegebenen Dokumentnummer verknüpft sind.
	// Kann wiederholt werden, um mehrere Dokumentnummern zu selektieren. Hinterlegt ist eine ODER-Suche.
	FDokumentnummer *DokumentnummerFilter `form:"f.dokumentnummer,omitempty" json:"f.dokumentnummer,omitempty"`

	// FId ID der Entität
	//
	// Kann wiederholt werden, um mehrere Entitäten zu selektieren.
	FId *IdFilter `form:"f.id,omitempty" json:"f.id,omitempty"`

	// FVorgangstyp Vorgangstyp
	//
	// Selektiert alle Entitäten, die dem angegebenen Vorgangstyp zugeordnet sind.
	// Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.
	FVorgangstyp *VorgangstypFilter `form:"f.vorgangstyp,omitempty" json:"f.vorgangstyp,omitempty"`

	// FVorgangstypNotation Vorgangstyp-Notation
	//
	// Selektiert alle Entitäten, die der angegebenen Vorgangstyp-Notation zugeordnet sind.
	// Kann wiederholt werden, um mehrere Vorgangstypen zu selektieren. Hinterlegt ist eine ODER-Suche.
	FVorgangstypNotation *VorgangstypNotationFilter `form:"f.vorgangstyp_notation,omitempty" json:"f.vorgangstyp_notation,omitempty"`

	// FWahlperiode Nummer der Wahlperiode
	//
	// Selektiert alle Entitäten, die der angegebenen Wahlperiode zugeordnet sind.
	// Kann wiederholt werden, um mehrere Wahlperioden zu selektieren. Hinterlegt ist eine ODER-Suche.
	FWahlperiode *WahlperiodeFilter `form:"f.wahlperiode,omitempty" json:"f.wahlperiode,omitempty"`

	// FZuordnung Zuordnung der Entität zum Bundestag, Bundesrat, Bundesversammlung oder Europakammer
	FZuordnung *ZuordnungFilter `form:"f.zuordnung,omitempty" json:"f.zuordnung,omitempty"`

	// Cursor Position des Cursors zur Anfrage weiterer Entitäten
	//
	// Übersteigt die Anzahl der gefundenen Entitäten das jeweilige Limit, muss eine Folgeanfrage gestellt werden, um weitere Entitäten zu laden.
	// Eine Folgeanfrage wird gebildet, indem alle Parameter der ursprünglichen Anfrage wiederholt werden und zusätzlich der cursor Parameter der letzten Antwort eingesetzt wird.
	// Es können solange Folgeanfragen gestellt werden, bis sich der cursor nicht mehr ändert. Dies signalisiert, dass alle Entitäten geladen wurden.
	Cursor *Cursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML.
	Format *GetPlenarprotokollTextListParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPlenarprotokollTextListParamsFormat defines parameters for GetPlenarprotokollTextList.
type GetPlenarprotokollTextListParamsFormat string

// GetPlenarprotokollTextParams defines parameters for GetPlenarprotokollText.
type GetPlenarprotokollTextParams struct {
	// Format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML.
	Format *GetPlenarprotokollTextParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPlenarprotokollTextParamsFormat defines parameters for GetPlenarprotokollText.
type GetPlenarprotokollTextParamsFormat string

// GetPlenarprotokollParams defines parameters for GetPlenarprotokoll.
type GetPlenarprotokollParams struct {
	// Format Steuert das Datenformat der Antwort, möglich sind JSON (voreingestellt) oder XML.
	Format *GetPlenarprotokollParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPlenarprotokollParamsFormat defines parameters for GetPlenarprotokoll.
type GetPlenarprotokollParamsFormat string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetPlenarprotokollList request
	GetPlenarprotokollList(ctx context.Context, params *GetPlenarprotokollListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlenarprotokollTextList request
	GetPlenarprotokollTextList(ctx context.Context, params *GetPlenarprotokollTextListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlenarprotokollText request
	GetPlenarprotokollText(ctx context.Context, id Id, params *GetPlenarprotokollTextParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlenarprotokoll request
	GetPlenarprotokoll(ctx context.Context, id Id, params *GetPlenarprotokollParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetPlenarprotokollList(ctx context.Context, params *GetPlenarprotokollListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlenarprotokollListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlenarprotokollTextList(ctx context.Context, params *GetPlenarprotokollTextListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlenarprotokollTextListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlenarprotokollText(ctx context.Context, id Id, params *GetPlenarprotokollTextParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlenarprotokollTextRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlenarprotokoll(ctx context.Context, id Id, params *GetPlenarprotokollParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlenarprotokollRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetPlenarprotokollListRequest generates requests for GetPlenarprotokollList
func NewGetPlenarprotokollListRequest(server string, params *GetPlenarprotokollListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plenarprotokoll")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FAktualisiertStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.aktualisiert.start", runtime.ParamLocationQuery, *params.FAktualisiertStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FAktualisiertEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.aktualisiert.end", runtime.ParamLocationQuery, *params.FAktualisiertEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FDatumStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.datum.start", runtime.ParamLocationQuery, *params.FDatumStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FDatumEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.datum.end", runtime.ParamLocationQuery, *params.FDatumEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FDokumentnummer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.dokumentnummer", runtime.ParamLocationQuery, *params.FDokumentnummer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.id", runtime.ParamLocationQuery, *params.FId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FVorgangstyp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.vorgangstyp", runtime.ParamLocationQuery, *params.FVorgangstyp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FVorgangstypNotation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.vorgangstyp_notation", runtime.ParamLocationQuery, *params.FVorgangstypNotation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FWahlperiode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.wahlperiode", runtime.ParamLocationQuery, *params.FWahlperiode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FZuordnung != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.zuordnung", runtime.ParamLocationQuery, *params.FZuordnung); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlenarprotokollTextListRequest generates requests for GetPlenarprotokollTextList
func NewGetPlenarprotokollTextListRequest(server string, params *GetPlenarprotokollTextListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plenarprotokoll-text")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FAktualisiertStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.aktualisiert.start", runtime.ParamLocationQuery, *params.FAktualisiertStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FAktualisiertEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.aktualisiert.end", runtime.ParamLocationQuery, *params.FAktualisiertEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FDatumStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.datum.start", runtime.ParamLocationQuery, *params.FDatumStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FDatumEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.datum.end", runtime.ParamLocationQuery, *params.FDatumEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FDokumentnummer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.dokumentnummer", runtime.ParamLocationQuery, *params.FDokumentnummer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.id", runtime.ParamLocationQuery, *params.FId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FVorgangstyp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.vorgangstyp", runtime.ParamLocationQuery, *params.FVorgangstyp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FVorgangstypNotation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.vorgangstyp_notation", runtime.ParamLocationQuery, *params.FVorgangstypNotation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FWahlperiode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.wahlperiode", runtime.ParamLocationQuery, *params.FWahlperiode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FZuordnung != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f.zuordnung", runtime.ParamLocationQuery, *params.FZuordnung); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlenarprotokollTextRequest generates requests for GetPlenarprotokollText
func NewGetPlenarprotokollTextRequest(server string, id Id, params *GetPlenarprotokollTextParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plenarprotokoll-text/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlenarprotokollRequest generates requests for GetPlenarprotokoll
func NewGetPlenarprotokollRequest(server string, id Id, params *GetPlenarprotokollParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plenarprotokoll/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetPlenarprotokollListWithResponse request
	GetPlenarprotokollListWithResponse(ctx context.Context, params *GetPlenarprotokollListParams, reqEditors ...RequestEditorFn) (*GetPlenarprotokollListResponse, error)

	// GetPlenarprotokollTextListWithResponse request
	GetPlenarprotokollTextListWithResponse(ctx context.Context, params *GetPlenarprotokollTextListParams, reqEditors ...RequestEditorFn) (*GetPlenarprotokollTextListResponse, error)

	// GetPlenarprotokollTextWithResponse request
	GetPlenarprotokollTextWithResponse(ctx context.Context, id Id, params *GetPlenarprotokollTextParams, reqEditors ...RequestEditorFn) (*GetPlenarprotokollTextResponse, error)

	// GetPlenarprotokollWithResponse request
	GetPlenarprotokollWithResponse(ctx context.Context, id Id, params *GetPlenarprotokollParams, reqEditors ...RequestEditorFn) (*GetPlenarprotokollResponse, error)
}

type GetPlenarprotokollListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlenarprotokollListResponse
	XML200       *PlenarprotokollListResponse
	JSON400      *BadRequestResponse
	JSON401      *UnauthorizedResponse
}

// Status returns HTTPResponse.Status
func (r GetPlenarprotokollListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlenarprotokollListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlenarprotokollTextListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlenarprotokollTextListResponse
	XML200       *PlenarprotokollTextListResponse
	JSON400      *BadRequestResponse
	JSON401      *UnauthorizedResponse
}

// Status returns HTTPResponse.Status
func (r GetPlenarprotokollTextListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlenarprotokollTextListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlenarprotokollTextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlenarprotokollText
	XML200       *PlenarprotokollText
	JSON401      *UnauthorizedResponse
	JSON404      *NotFoundResponse
}

// Status returns HTTPResponse.Status
func (r GetPlenarprotokollTextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlenarprotokollTextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlenarprotokollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plenarprotokoll
	XML200       *Plenarprotokoll
	JSON401      *UnauthorizedResponse
	JSON404      *NotFoundResponse
}

// Status returns HTTPResponse.Status
func (r GetPlenarprotokollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlenarprotokollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetPlenarprotokollListWithResponse request returning *GetPlenarprotokollListResponse
func (c *ClientWithResponses) GetPlenarprotokollListWithResponse(ctx context.Context, params *GetPlenarprotokollListParams, reqEditors ...RequestEditorFn) (*GetPlenarprotokollListResponse, error) {
	rsp, err := c.GetPlenarprotokollList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlenarprotokollListResponse(rsp)
}

// GetPlenarprotokollTextListWithResponse request returning *GetPlenarprotokollTextListResponse
func (c *ClientWithResponses) GetPlenarprotokollTextListWithResponse(ctx context.Context, params *GetPlenarprotokollTextListParams, reqEditors ...RequestEditorFn) (*GetPlenarprotokollTextListResponse, error) {
	rsp, err := c.GetPlenarprotokollTextList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlenarprotokollTextListResponse(rsp)
}

// GetPlenarprotokollTextWithResponse request returning *GetPlenarprotokollTextResponse
func (c *ClientWithResponses) GetPlenarprotokollTextWithResponse(ctx context.Context, id Id, params *GetPlenarprotokollTextParams, reqEditors ...RequestEditorFn) (*GetPlenarprotokollTextResponse, error) {
	rsp, err := c.GetPlenarprotokollText(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlenarprotokollTextResponse(rsp)
}

// GetPlenarprotokollWithResponse request returning *GetPlenarprotokollResponse
func (c *ClientWithResponses) GetPlenarprotokollWithResponse(ctx context.Context, id Id, params *GetPlenarprotokollParams, reqEditors ...RequestEditorFn) (*GetPlenarprotokollResponse, error) {
	rsp, err := c.GetPlenarprotokoll(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlenarprotokollResponse(rsp)
}

// ParseGetPlenarprotokollListResponse parses an HTTP response from a GetPlenarprotokollListWithResponse call
func ParseGetPlenarprotokollListResponse(rsp *http.Response) (*GetPlenarprotokollListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlenarprotokollListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlenarprotokollListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest PlenarprotokollListResponse
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetPlenarprotokollTextListResponse parses an HTTP response from a GetPlenarprotokollTextListWithResponse call
func ParseGetPlenarprotokollTextListResponse(rsp *http.Response) (*GetPlenarprotokollTextListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlenarprotokollTextListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlenarprotokollTextListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest PlenarprotokollTextListResponse
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetPlenarprotokollTextResponse parses an HTTP response from a GetPlenarprotokollTextWithResponse call
func ParseGetPlenarprotokollTextResponse(rsp *http.Response) (*GetPlenarprotokollTextResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlenarprotokollTextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlenarprotokollText
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest PlenarprotokollText
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}

// ParseGetPlenarprotokollResponse parses an HTTP response from a GetPlenarprotokollWithResponse call
func ParseGetPlenarprotokollResponse(rsp *http.Response) (*GetPlenarprotokollResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlenarprotokollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plenarprotokoll
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
		var dest Plenarprotokoll
		if err := xml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.XML200 = &dest

	}

	return response, nil
}
