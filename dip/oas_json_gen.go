// Code generated by ogen, DO NOT EDIT.

package dip

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Aktivitaet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Aktivitaet) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("aktivitaetsart")
		e.Str(s.Aktivitaetsart)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
	{
		e.FieldStart("dokumentart")
		s.Dokumentart.Encode(e)
	}
	{
		e.FieldStart("wahlperiode")
		e.Int32(s.Wahlperiode)
	}
	{
		e.FieldStart("datum")
		json.EncodeDate(e, s.Datum)
	}
	{
		e.FieldStart("aktualisiert")
		json.EncodeDateTime(e, s.Aktualisiert)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		e.FieldStart("fundstelle")
		s.Fundstelle.Encode(e)
	}
	{
		if s.Vorgangsbezug != nil {
			e.FieldStart("vorgangsbezug")
			e.ArrStart()
			for _, elem := range s.Vorgangsbezug {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("vorgangsbezug_anzahl")
		e.Int32(s.VorgangsbezugAnzahl)
	}
	{
		if s.Deskriptor != nil {
			e.FieldStart("deskriptor")
			e.ArrStart()
			for _, elem := range s.Deskriptor {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Abstract.Set {
			e.FieldStart("abstract")
			s.Abstract.Encode(e)
		}
	}
}

var jsonFieldsNameOfAktivitaet = [13]string{
	0:  "id",
	1:  "aktivitaetsart",
	2:  "typ",
	3:  "dokumentart",
	4:  "wahlperiode",
	5:  "datum",
	6:  "aktualisiert",
	7:  "titel",
	8:  "fundstelle",
	9:  "vorgangsbezug",
	10: "vorgangsbezug_anzahl",
	11: "deskriptor",
	12: "abstract",
}

// Decode decodes Aktivitaet from json.
func (s *Aktivitaet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Aktivitaet to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "aktivitaetsart":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Aktivitaetsart = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktivitaetsart\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "dokumentart":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Dokumentart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentart\"")
			}
		case "wahlperiode":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Wahlperiode = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode\"")
			}
		case "datum":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Datum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "aktualisiert":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Aktualisiert = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktualisiert\"")
			}
		case "titel":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "fundstelle":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Fundstelle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundstelle\"")
			}
		case "vorgangsbezug":
			if err := func() error {
				s.Vorgangsbezug = make([]Vorgangspositionbezug, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vorgangspositionbezug
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Vorgangsbezug = append(s.Vorgangsbezug, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug\"")
			}
		case "vorgangsbezug_anzahl":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.VorgangsbezugAnzahl = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug_anzahl\"")
			}
		case "deskriptor":
			if err := func() error {
				s.Deskriptor = make([]Deskriptor, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Deskriptor
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Deskriptor = append(s.Deskriptor, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deskriptor\"")
			}
		case "abstract":
			if err := func() error {
				s.Abstract.Reset()
				if err := s.Abstract.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abstract\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Aktivitaet")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAktivitaet) {
					name = jsonFieldsNameOfAktivitaet[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Aktivitaet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Aktivitaet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AktivitaetAnzeige) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AktivitaetAnzeige) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("aktivitaetsart")
		e.Str(s.Aktivitaetsart)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		if s.PdfURL.Set {
			e.FieldStart("pdf_url")
			s.PdfURL.Encode(e)
		}
	}
	{
		if s.Seite.Set {
			e.FieldStart("seite")
			s.Seite.Encode(e)
		}
	}
}

var jsonFieldsNameOfAktivitaetAnzeige = [4]string{
	0: "aktivitaetsart",
	1: "titel",
	2: "pdf_url",
	3: "seite",
}

// Decode decodes AktivitaetAnzeige from json.
func (s *AktivitaetAnzeige) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AktivitaetAnzeige to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aktivitaetsart":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Aktivitaetsart = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktivitaetsart\"")
			}
		case "titel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "pdf_url":
			if err := func() error {
				s.PdfURL.Reset()
				if err := s.PdfURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdf_url\"")
			}
		case "seite":
			if err := func() error {
				s.Seite.Reset()
				if err := s.Seite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seite\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AktivitaetAnzeige")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAktivitaetAnzeige) {
					name = jsonFieldsNameOfAktivitaetAnzeige[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AktivitaetAnzeige) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AktivitaetAnzeige) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AktivitaetDokumentart as json.
func (s AktivitaetDokumentart) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AktivitaetDokumentart from json.
func (s *AktivitaetDokumentart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AktivitaetDokumentart to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AktivitaetDokumentart(v) {
	case AktivitaetDokumentartDrucksache:
		*s = AktivitaetDokumentartDrucksache
	case AktivitaetDokumentartPlenarprotokoll:
		*s = AktivitaetDokumentartPlenarprotokoll
	default:
		*s = AktivitaetDokumentart(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AktivitaetDokumentart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AktivitaetDokumentart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AktivitaetListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AktivitaetListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numFound")
		e.Int32(s.NumFound)
	}
	{
		e.FieldStart("cursor")
		e.Str(s.Cursor)
	}
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfAktivitaetListResponse = [3]string{
	0: "numFound",
	1: "cursor",
	2: "documents",
}

// Decode decodes AktivitaetListResponse from json.
func (s *AktivitaetListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AktivitaetListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numFound\"")
			}
		case "cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cursor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "documents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Documents = make([]Aktivitaet, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Aktivitaet
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AktivitaetListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAktivitaetListResponse) {
					name = jsonFieldsNameOfAktivitaetListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AktivitaetListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AktivitaetListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AktivitaetTyp as json.
func (s AktivitaetTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AktivitaetTyp from json.
func (s *AktivitaetTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AktivitaetTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AktivitaetTyp(v) {
	case AktivitaetTypAktivitT:
		*s = AktivitaetTypAktivitT
	default:
		*s = AktivitaetTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AktivitaetTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AktivitaetTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequestResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequestResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfBadRequestResponse = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes BadRequestResponse from json.
func (s *BadRequestResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequestResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBadRequestResponse) {
					name = jsonFieldsNameOfBadRequestResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequestResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BadRequestResponseCode as json.
func (s BadRequestResponseCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes BadRequestResponseCode from json.
func (s *BadRequestResponseCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestResponseCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = BadRequestResponseCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BadRequestResponseCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestResponseCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Beschlussfassung) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Beschlussfassung) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("beschlusstenor")
		e.Str(s.Beschlusstenor)
	}
	{
		if s.Seite.Set {
			e.FieldStart("seite")
			s.Seite.Encode(e)
		}
	}
	{
		if s.Abstimmungsart.Set {
			e.FieldStart("abstimmungsart")
			s.Abstimmungsart.Encode(e)
		}
	}
	{
		if s.AbstimmErgebnisBemerkung.Set {
			e.FieldStart("abstimm_ergebnis_bemerkung")
			s.AbstimmErgebnisBemerkung.Encode(e)
		}
	}
	{
		if s.Grundlage.Set {
			e.FieldStart("grundlage")
			s.Grundlage.Encode(e)
		}
	}
	{
		if s.Dokumentnummer.Set {
			e.FieldStart("dokumentnummer")
			s.Dokumentnummer.Encode(e)
		}
	}
	{
		if s.Mehrheit.Set {
			e.FieldStart("mehrheit")
			s.Mehrheit.Encode(e)
		}
	}
}

var jsonFieldsNameOfBeschlussfassung = [7]string{
	0: "beschlusstenor",
	1: "seite",
	2: "abstimmungsart",
	3: "abstimm_ergebnis_bemerkung",
	4: "grundlage",
	5: "dokumentnummer",
	6: "mehrheit",
}

// Decode decodes Beschlussfassung from json.
func (s *Beschlussfassung) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Beschlussfassung to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "beschlusstenor":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Beschlusstenor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beschlusstenor\"")
			}
		case "seite":
			if err := func() error {
				s.Seite.Reset()
				if err := s.Seite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seite\"")
			}
		case "abstimmungsart":
			if err := func() error {
				s.Abstimmungsart.Reset()
				if err := s.Abstimmungsart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abstimmungsart\"")
			}
		case "abstimm_ergebnis_bemerkung":
			if err := func() error {
				s.AbstimmErgebnisBemerkung.Reset()
				if err := s.AbstimmErgebnisBemerkung.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abstimm_ergebnis_bemerkung\"")
			}
		case "grundlage":
			if err := func() error {
				s.Grundlage.Reset()
				if err := s.Grundlage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"grundlage\"")
			}
		case "dokumentnummer":
			if err := func() error {
				s.Dokumentnummer.Reset()
				if err := s.Dokumentnummer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentnummer\"")
			}
		case "mehrheit":
			if err := func() error {
				s.Mehrheit.Reset()
				if err := s.Mehrheit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mehrheit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Beschlussfassung")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBeschlussfassung) {
					name = jsonFieldsNameOfBeschlussfassung[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Beschlussfassung) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Beschlussfassung) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BeschlussfassungAbstimmungsart as json.
func (s BeschlussfassungAbstimmungsart) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BeschlussfassungAbstimmungsart from json.
func (s *BeschlussfassungAbstimmungsart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BeschlussfassungAbstimmungsart to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BeschlussfassungAbstimmungsart(v) {
	case BeschlussfassungAbstimmungsartAbstimmungDurchAufrufDerLNder:
		*s = BeschlussfassungAbstimmungsartAbstimmungDurchAufrufDerLNder
	case BeschlussfassungAbstimmungsartGeheimeWahl:
		*s = BeschlussfassungAbstimmungsartGeheimeWahl
	case BeschlussfassungAbstimmungsartHammelsprung:
		*s = BeschlussfassungAbstimmungsartHammelsprung
	case BeschlussfassungAbstimmungsartNamentlicheAbstimmung:
		*s = BeschlussfassungAbstimmungsartNamentlicheAbstimmung
	case BeschlussfassungAbstimmungsartVerhLtniswahl:
		*s = BeschlussfassungAbstimmungsartVerhLtniswahl
	default:
		*s = BeschlussfassungAbstimmungsart(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BeschlussfassungAbstimmungsart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BeschlussfassungAbstimmungsart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BeschlussfassungMehrheit as json.
func (s BeschlussfassungMehrheit) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BeschlussfassungMehrheit from json.
func (s *BeschlussfassungMehrheit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BeschlussfassungMehrheit to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BeschlussfassungMehrheit(v) {
	case BeschlussfassungMehrheitAbsoluteMehrheit:
		*s = BeschlussfassungMehrheitAbsoluteMehrheit
	case BeschlussfassungMehrheitZweidrittelmehrheit:
		*s = BeschlussfassungMehrheitZweidrittelmehrheit
	default:
		*s = BeschlussfassungMehrheit(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BeschlussfassungMehrheit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BeschlussfassungMehrheit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Bundesland as json.
func (s Bundesland) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Bundesland from json.
func (s *Bundesland) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Bundesland to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Bundesland(v) {
	case BundeslandBadenWRttemberg:
		*s = BundeslandBadenWRttemberg
	case BundeslandBayern:
		*s = BundeslandBayern
	case BundeslandBerlin:
		*s = BundeslandBerlin
	case BundeslandBrandenburg:
		*s = BundeslandBrandenburg
	case BundeslandBremen:
		*s = BundeslandBremen
	case BundeslandHamburg:
		*s = BundeslandHamburg
	case BundeslandHessen:
		*s = BundeslandHessen
	case BundeslandMecklenburgVorpommern:
		*s = BundeslandMecklenburgVorpommern
	case BundeslandNiedersachsen:
		*s = BundeslandNiedersachsen
	case BundeslandNordrheinWestfalen:
		*s = BundeslandNordrheinWestfalen
	case BundeslandRheinlandPfalz:
		*s = BundeslandRheinlandPfalz
	case BundeslandSaarland:
		*s = BundeslandSaarland
	case BundeslandSachsen:
		*s = BundeslandSachsen
	case BundeslandSachsenAnhalt:
		*s = BundeslandSachsenAnhalt
	case BundeslandSchleswigHolstein:
		*s = BundeslandSchleswigHolstein
	case BundeslandThRingen:
		*s = BundeslandThRingen
	default:
		*s = Bundesland(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Bundesland) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Bundesland) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Deskriptor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Deskriptor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
}

var jsonFieldsNameOfDeskriptor = [2]string{
	0: "name",
	1: "typ",
}

// Decode decodes Deskriptor from json.
func (s *Deskriptor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Deskriptor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Deskriptor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeskriptor) {
					name = jsonFieldsNameOfDeskriptor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Deskriptor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Deskriptor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeskriptorTyp as json.
func (s DeskriptorTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeskriptorTyp from json.
func (s *DeskriptorTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeskriptorTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeskriptorTyp(v) {
	case DeskriptorTypFreierDeskriptor:
		*s = DeskriptorTypFreierDeskriptor
	case DeskriptorTypGeographBegriffe:
		*s = DeskriptorTypGeographBegriffe
	case DeskriptorTypInstitutionen:
		*s = DeskriptorTypInstitutionen
	case DeskriptorTypPersonen:
		*s = DeskriptorTypPersonen
	case DeskriptorTypRechtsmaterialien:
		*s = DeskriptorTypRechtsmaterialien
	case DeskriptorTypSachbegriffe:
		*s = DeskriptorTypSachbegriffe
	default:
		*s = DeskriptorTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeskriptorTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeskriptorTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Drucksache) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Drucksache) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
	{
		e.FieldStart("dokumentart")
		s.Dokumentart.Encode(e)
	}
	{
		e.FieldStart("drucksachetyp")
		e.Str(s.Drucksachetyp)
	}
	{
		e.FieldStart("dokumentnummer")
		e.Str(s.Dokumentnummer)
	}
	{
		if s.Wahlperiode.Set {
			e.FieldStart("wahlperiode")
			s.Wahlperiode.Encode(e)
		}
	}
	{
		e.FieldStart("herausgeber")
		s.Herausgeber.Encode(e)
	}
	{
		e.FieldStart("datum")
		json.EncodeDate(e, s.Datum)
	}
	{
		e.FieldStart("aktualisiert")
		json.EncodeDateTime(e, s.Aktualisiert)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		if s.AutorenAnzeige != nil {
			e.FieldStart("autoren_anzeige")
			e.ArrStart()
			for _, elem := range s.AutorenAnzeige {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("autoren_anzahl")
		e.Int32(s.AutorenAnzahl)
	}
	{
		e.FieldStart("fundstelle")
		s.Fundstelle.Encode(e)
	}
	{
		if s.PdfHash.Set {
			e.FieldStart("pdf_hash")
			s.PdfHash.Encode(e)
		}
	}
	{
		if s.Urheber != nil {
			e.FieldStart("urheber")
			e.ArrStart()
			for _, elem := range s.Urheber {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Vorgangsbezug != nil {
			e.FieldStart("vorgangsbezug")
			e.ArrStart()
			for _, elem := range s.Vorgangsbezug {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("vorgangsbezug_anzahl")
		e.Int32(s.VorgangsbezugAnzahl)
	}
	{
		if s.Ressort != nil {
			e.FieldStart("ressort")
			e.ArrStart()
			for _, elem := range s.Ressort {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Anlagen.Set {
			e.FieldStart("anlagen")
			s.Anlagen.Encode(e)
		}
	}
}

var jsonFieldsNameOfDrucksache = [19]string{
	0:  "id",
	1:  "typ",
	2:  "dokumentart",
	3:  "drucksachetyp",
	4:  "dokumentnummer",
	5:  "wahlperiode",
	6:  "herausgeber",
	7:  "datum",
	8:  "aktualisiert",
	9:  "titel",
	10: "autoren_anzeige",
	11: "autoren_anzahl",
	12: "fundstelle",
	13: "pdf_hash",
	14: "urheber",
	15: "vorgangsbezug",
	16: "vorgangsbezug_anzahl",
	17: "ressort",
	18: "anlagen",
}

// Decode decodes Drucksache from json.
func (s *Drucksache) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Drucksache to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "dokumentart":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Dokumentart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentart\"")
			}
		case "drucksachetyp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Drucksachetyp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drucksachetyp\"")
			}
		case "dokumentnummer":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Dokumentnummer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentnummer\"")
			}
		case "wahlperiode":
			if err := func() error {
				s.Wahlperiode.Reset()
				if err := s.Wahlperiode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode\"")
			}
		case "herausgeber":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Herausgeber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"herausgeber\"")
			}
		case "datum":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Datum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "aktualisiert":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Aktualisiert = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktualisiert\"")
			}
		case "titel":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "autoren_anzeige":
			if err := func() error {
				s.AutorenAnzeige = make([]DrucksacheAutorenAnzeigeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DrucksacheAutorenAnzeigeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AutorenAnzeige = append(s.AutorenAnzeige, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoren_anzeige\"")
			}
		case "autoren_anzahl":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.AutorenAnzahl = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoren_anzahl\"")
			}
		case "fundstelle":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Fundstelle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundstelle\"")
			}
		case "pdf_hash":
			if err := func() error {
				s.PdfHash.Reset()
				if err := s.PdfHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdf_hash\"")
			}
		case "urheber":
			if err := func() error {
				s.Urheber = make([]Urheber, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Urheber
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Urheber = append(s.Urheber, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urheber\"")
			}
		case "vorgangsbezug":
			if err := func() error {
				s.Vorgangsbezug = make([]Vorgangsbezug, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vorgangsbezug
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Vorgangsbezug = append(s.Vorgangsbezug, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug\"")
			}
		case "vorgangsbezug_anzahl":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.VorgangsbezugAnzahl = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug_anzahl\"")
			}
		case "ressort":
			if err := func() error {
				s.Ressort = make([]Ressort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Ressort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ressort = append(s.Ressort, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ressort\"")
			}
		case "anlagen":
			if err := func() error {
				s.Anlagen.Reset()
				if err := s.Anlagen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anlagen\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Drucksache")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11011111,
		0b00011011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDrucksache) {
					name = jsonFieldsNameOfDrucksache[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Drucksache) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Drucksache) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DrucksacheAutorenAnzeigeItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DrucksacheAutorenAnzeigeItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("autor_titel")
		e.Str(s.AutorTitel)
	}
}

var jsonFieldsNameOfDrucksacheAutorenAnzeigeItem = [3]string{
	0: "id",
	1: "title",
	2: "autor_titel",
}

// Decode decodes DrucksacheAutorenAnzeigeItem from json.
func (s *DrucksacheAutorenAnzeigeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheAutorenAnzeigeItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "autor_titel":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AutorTitel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autor_titel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DrucksacheAutorenAnzeigeItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDrucksacheAutorenAnzeigeItem) {
					name = jsonFieldsNameOfDrucksacheAutorenAnzeigeItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DrucksacheAutorenAnzeigeItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheAutorenAnzeigeItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DrucksacheDokumentart as json.
func (s DrucksacheDokumentart) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DrucksacheDokumentart from json.
func (s *DrucksacheDokumentart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheDokumentart to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DrucksacheDokumentart(v) {
	case DrucksacheDokumentartDrucksache:
		*s = DrucksacheDokumentartDrucksache
	default:
		*s = DrucksacheDokumentart(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DrucksacheDokumentart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheDokumentart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DrucksacheHerausgeber as json.
func (s DrucksacheHerausgeber) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DrucksacheHerausgeber from json.
func (s *DrucksacheHerausgeber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheHerausgeber to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DrucksacheHerausgeber(v) {
	case DrucksacheHerausgeberBT:
		*s = DrucksacheHerausgeberBT
	case DrucksacheHerausgeberBR:
		*s = DrucksacheHerausgeberBR
	default:
		*s = DrucksacheHerausgeber(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DrucksacheHerausgeber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheHerausgeber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DrucksacheListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DrucksacheListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numFound")
		e.Int32(s.NumFound)
	}
	{
		e.FieldStart("cursor")
		e.Str(s.Cursor)
	}
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDrucksacheListResponse = [3]string{
	0: "numFound",
	1: "cursor",
	2: "documents",
}

// Decode decodes DrucksacheListResponse from json.
func (s *DrucksacheListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numFound\"")
			}
		case "cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cursor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "documents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Documents = make([]Drucksache, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Drucksache
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DrucksacheListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDrucksacheListResponse) {
					name = jsonFieldsNameOfDrucksacheListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DrucksacheListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DrucksacheText) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DrucksacheText) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
	{
		e.FieldStart("dokumentart")
		s.Dokumentart.Encode(e)
	}
	{
		e.FieldStart("drucksachetyp")
		e.Str(s.Drucksachetyp)
	}
	{
		e.FieldStart("dokumentnummer")
		e.Str(s.Dokumentnummer)
	}
	{
		if s.Wahlperiode.Set {
			e.FieldStart("wahlperiode")
			s.Wahlperiode.Encode(e)
		}
	}
	{
		e.FieldStart("herausgeber")
		s.Herausgeber.Encode(e)
	}
	{
		e.FieldStart("datum")
		json.EncodeDate(e, s.Datum)
	}
	{
		e.FieldStart("aktualisiert")
		json.EncodeDateTime(e, s.Aktualisiert)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		if s.AutorenAnzeige != nil {
			e.FieldStart("autoren_anzeige")
			e.ArrStart()
			for _, elem := range s.AutorenAnzeige {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("autoren_anzahl")
		e.Int32(s.AutorenAnzahl)
	}
	{
		e.FieldStart("fundstelle")
		s.Fundstelle.Encode(e)
	}
	{
		if s.PdfHash.Set {
			e.FieldStart("pdf_hash")
			s.PdfHash.Encode(e)
		}
	}
	{
		if s.Urheber != nil {
			e.FieldStart("urheber")
			e.ArrStart()
			for _, elem := range s.Urheber {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Vorgangsbezug != nil {
			e.FieldStart("vorgangsbezug")
			e.ArrStart()
			for _, elem := range s.Vorgangsbezug {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("vorgangsbezug_anzahl")
		e.Int32(s.VorgangsbezugAnzahl)
	}
	{
		if s.Ressort != nil {
			e.FieldStart("ressort")
			e.ArrStart()
			for _, elem := range s.Ressort {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Anlagen.Set {
			e.FieldStart("anlagen")
			s.Anlagen.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfDrucksacheText = [20]string{
	0:  "id",
	1:  "typ",
	2:  "dokumentart",
	3:  "drucksachetyp",
	4:  "dokumentnummer",
	5:  "wahlperiode",
	6:  "herausgeber",
	7:  "datum",
	8:  "aktualisiert",
	9:  "titel",
	10: "autoren_anzeige",
	11: "autoren_anzahl",
	12: "fundstelle",
	13: "pdf_hash",
	14: "urheber",
	15: "vorgangsbezug",
	16: "vorgangsbezug_anzahl",
	17: "ressort",
	18: "anlagen",
	19: "text",
}

// Decode decodes DrucksacheText from json.
func (s *DrucksacheText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheText to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "dokumentart":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Dokumentart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentart\"")
			}
		case "drucksachetyp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Drucksachetyp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drucksachetyp\"")
			}
		case "dokumentnummer":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Dokumentnummer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentnummer\"")
			}
		case "wahlperiode":
			if err := func() error {
				s.Wahlperiode.Reset()
				if err := s.Wahlperiode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode\"")
			}
		case "herausgeber":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Herausgeber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"herausgeber\"")
			}
		case "datum":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Datum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "aktualisiert":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Aktualisiert = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktualisiert\"")
			}
		case "titel":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "autoren_anzeige":
			if err := func() error {
				s.AutorenAnzeige = make([]DrucksacheTextAutorenAnzeigeItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DrucksacheTextAutorenAnzeigeItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AutorenAnzeige = append(s.AutorenAnzeige, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoren_anzeige\"")
			}
		case "autoren_anzahl":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.AutorenAnzahl = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoren_anzahl\"")
			}
		case "fundstelle":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.Fundstelle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundstelle\"")
			}
		case "pdf_hash":
			if err := func() error {
				s.PdfHash.Reset()
				if err := s.PdfHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdf_hash\"")
			}
		case "urheber":
			if err := func() error {
				s.Urheber = make([]Urheber, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Urheber
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Urheber = append(s.Urheber, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urheber\"")
			}
		case "vorgangsbezug":
			if err := func() error {
				s.Vorgangsbezug = make([]Vorgangsbezug, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vorgangsbezug
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Vorgangsbezug = append(s.Vorgangsbezug, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug\"")
			}
		case "vorgangsbezug_anzahl":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.VorgangsbezugAnzahl = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug_anzahl\"")
			}
		case "ressort":
			if err := func() error {
				s.Ressort = make([]Ressort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Ressort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ressort = append(s.Ressort, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ressort\"")
			}
		case "anlagen":
			if err := func() error {
				s.Anlagen.Reset()
				if err := s.Anlagen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anlagen\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DrucksacheText")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11011111,
		0b00011011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDrucksacheText) {
					name = jsonFieldsNameOfDrucksacheText[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DrucksacheText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DrucksacheTextAutorenAnzeigeItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DrucksacheTextAutorenAnzeigeItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("autor_titel")
		e.Str(s.AutorTitel)
	}
}

var jsonFieldsNameOfDrucksacheTextAutorenAnzeigeItem = [3]string{
	0: "id",
	1: "title",
	2: "autor_titel",
}

// Decode decodes DrucksacheTextAutorenAnzeigeItem from json.
func (s *DrucksacheTextAutorenAnzeigeItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheTextAutorenAnzeigeItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "autor_titel":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.AutorTitel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autor_titel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DrucksacheTextAutorenAnzeigeItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDrucksacheTextAutorenAnzeigeItem) {
					name = jsonFieldsNameOfDrucksacheTextAutorenAnzeigeItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DrucksacheTextAutorenAnzeigeItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheTextAutorenAnzeigeItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DrucksacheTextDokumentart as json.
func (s DrucksacheTextDokumentart) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DrucksacheTextDokumentart from json.
func (s *DrucksacheTextDokumentart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheTextDokumentart to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DrucksacheTextDokumentart(v) {
	case DrucksacheTextDokumentartDrucksache:
		*s = DrucksacheTextDokumentartDrucksache
	default:
		*s = DrucksacheTextDokumentart(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DrucksacheTextDokumentart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheTextDokumentart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DrucksacheTextHerausgeber as json.
func (s DrucksacheTextHerausgeber) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DrucksacheTextHerausgeber from json.
func (s *DrucksacheTextHerausgeber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheTextHerausgeber to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DrucksacheTextHerausgeber(v) {
	case DrucksacheTextHerausgeberBT:
		*s = DrucksacheTextHerausgeberBT
	case DrucksacheTextHerausgeberBR:
		*s = DrucksacheTextHerausgeberBR
	default:
		*s = DrucksacheTextHerausgeber(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DrucksacheTextHerausgeber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheTextHerausgeber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DrucksacheTextListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DrucksacheTextListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numFound")
		e.Int32(s.NumFound)
	}
	{
		e.FieldStart("cursor")
		e.Str(s.Cursor)
	}
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDrucksacheTextListResponse = [3]string{
	0: "numFound",
	1: "cursor",
	2: "documents",
}

// Decode decodes DrucksacheTextListResponse from json.
func (s *DrucksacheTextListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheTextListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numFound\"")
			}
		case "cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cursor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "documents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Documents = make([]DrucksacheText, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DrucksacheText
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DrucksacheTextListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDrucksacheTextListResponse) {
					name = jsonFieldsNameOfDrucksacheTextListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DrucksacheTextListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheTextListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DrucksacheTextTyp as json.
func (s DrucksacheTextTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DrucksacheTextTyp from json.
func (s *DrucksacheTextTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheTextTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DrucksacheTextTyp(v) {
	case DrucksacheTextTypDokument:
		*s = DrucksacheTextTypDokument
	default:
		*s = DrucksacheTextTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DrucksacheTextTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheTextTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DrucksacheTyp as json.
func (s DrucksacheTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DrucksacheTyp from json.
func (s *DrucksacheTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DrucksacheTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DrucksacheTyp(v) {
	case DrucksacheTypDokument:
		*s = DrucksacheTypDokument
	default:
		*s = DrucksacheTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DrucksacheTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DrucksacheTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Fundstelle) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Fundstelle) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("dokumentart")
		s.Dokumentart.Encode(e)
	}
	{
		if s.PdfURL.Set {
			e.FieldStart("pdf_url")
			s.PdfURL.Encode(e)
		}
	}
	{
		e.FieldStart("dokumentnummer")
		e.Str(s.Dokumentnummer)
	}
	{
		e.FieldStart("datum")
		json.EncodeDate(e, s.Datum)
	}
	{
		if s.Drucksachetyp.Set {
			e.FieldStart("drucksachetyp")
			s.Drucksachetyp.Encode(e)
		}
	}
	{
		e.FieldStart("herausgeber")
		s.Herausgeber.Encode(e)
	}
	{
		e.FieldStart("urheber")
		e.ArrStart()
		for _, elem := range s.Urheber {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Verteildatum.Set {
			e.FieldStart("verteildatum")
			s.Verteildatum.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Seite.Set {
			e.FieldStart("seite")
			s.Seite.Encode(e)
		}
	}
	{
		if s.Anfangsseite.Set {
			e.FieldStart("anfangsseite")
			s.Anfangsseite.Encode(e)
		}
	}
	{
		if s.Endseite.Set {
			e.FieldStart("endseite")
			s.Endseite.Encode(e)
		}
	}
	{
		if s.Anfangsquadrant.Set {
			e.FieldStart("anfangsquadrant")
			s.Anfangsquadrant.Encode(e)
		}
	}
	{
		if s.Endquadrant.Set {
			e.FieldStart("endquadrant")
			s.Endquadrant.Encode(e)
		}
	}
	{
		if s.FrageNummer.Set {
			e.FieldStart("frage_nummer")
			s.FrageNummer.Encode(e)
		}
	}
	{
		if s.Anlagen.Set {
			e.FieldStart("anlagen")
			s.Anlagen.Encode(e)
		}
	}
	{
		if s.Top.Set {
			e.FieldStart("top")
			s.Top.Encode(e)
		}
	}
	{
		if s.TopZusatz.Set {
			e.FieldStart("top_zusatz")
			s.TopZusatz.Encode(e)
		}
	}
}

var jsonFieldsNameOfFundstelle = [18]string{
	0:  "id",
	1:  "dokumentart",
	2:  "pdf_url",
	3:  "dokumentnummer",
	4:  "datum",
	5:  "drucksachetyp",
	6:  "herausgeber",
	7:  "urheber",
	8:  "verteildatum",
	9:  "seite",
	10: "anfangsseite",
	11: "endseite",
	12: "anfangsquadrant",
	13: "endquadrant",
	14: "frage_nummer",
	15: "anlagen",
	16: "top",
	17: "top_zusatz",
}

// Decode decodes Fundstelle from json.
func (s *Fundstelle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Fundstelle to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dokumentart":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Dokumentart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentart\"")
			}
		case "pdf_url":
			if err := func() error {
				s.PdfURL.Reset()
				if err := s.PdfURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdf_url\"")
			}
		case "dokumentnummer":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Dokumentnummer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentnummer\"")
			}
		case "datum":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Datum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "drucksachetyp":
			if err := func() error {
				s.Drucksachetyp.Reset()
				if err := s.Drucksachetyp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drucksachetyp\"")
			}
		case "herausgeber":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Herausgeber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"herausgeber\"")
			}
		case "urheber":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Urheber = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Urheber = append(s.Urheber, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urheber\"")
			}
		case "verteildatum":
			if err := func() error {
				s.Verteildatum.Reset()
				if err := s.Verteildatum.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verteildatum\"")
			}
		case "seite":
			if err := func() error {
				s.Seite.Reset()
				if err := s.Seite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seite\"")
			}
		case "anfangsseite":
			if err := func() error {
				s.Anfangsseite.Reset()
				if err := s.Anfangsseite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anfangsseite\"")
			}
		case "endseite":
			if err := func() error {
				s.Endseite.Reset()
				if err := s.Endseite.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endseite\"")
			}
		case "anfangsquadrant":
			if err := func() error {
				s.Anfangsquadrant.Reset()
				if err := s.Anfangsquadrant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anfangsquadrant\"")
			}
		case "endquadrant":
			if err := func() error {
				s.Endquadrant.Reset()
				if err := s.Endquadrant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endquadrant\"")
			}
		case "frage_nummer":
			if err := func() error {
				s.FrageNummer.Reset()
				if err := s.FrageNummer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frage_nummer\"")
			}
		case "anlagen":
			if err := func() error {
				s.Anlagen.Reset()
				if err := s.Anlagen.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anlagen\"")
			}
		case "top":
			if err := func() error {
				s.Top.Reset()
				if err := s.Top.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top\"")
			}
		case "top_zusatz":
			if err := func() error {
				s.TopZusatz.Reset()
				if err := s.TopZusatz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_zusatz\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Fundstelle")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11011011,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFundstelle) {
					name = jsonFieldsNameOfFundstelle[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Fundstelle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Fundstelle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FundstelleDokumentart as json.
func (s FundstelleDokumentart) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FundstelleDokumentart from json.
func (s *FundstelleDokumentart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FundstelleDokumentart to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FundstelleDokumentart(v) {
	case FundstelleDokumentartDrucksache:
		*s = FundstelleDokumentartDrucksache
	case FundstelleDokumentartPlenarprotokoll:
		*s = FundstelleDokumentartPlenarprotokoll
	default:
		*s = FundstelleDokumentart(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FundstelleDokumentart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FundstelleDokumentart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Inkrafttreten) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Inkrafttreten) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("datum")
		json.EncodeDate(e, s.Datum)
	}
	{
		if s.Erlaeuterung.Set {
			e.FieldStart("erlaeuterung")
			s.Erlaeuterung.Encode(e)
		}
	}
}

var jsonFieldsNameOfInkrafttreten = [2]string{
	0: "datum",
	1: "erlaeuterung",
}

// Decode decodes Inkrafttreten from json.
func (s *Inkrafttreten) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Inkrafttreten to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "datum":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Datum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "erlaeuterung":
			if err := func() error {
				s.Erlaeuterung.Reset()
				if err := s.Erlaeuterung.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"erlaeuterung\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Inkrafttreten")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInkrafttreten) {
					name = jsonFieldsNameOfInkrafttreten[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Inkrafttreten) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Inkrafttreten) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFoundResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFoundResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfNotFoundResponse = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes NotFoundResponse from json.
func (s *NotFoundResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFoundResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFoundResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotFoundResponse) {
					name = jsonFieldsNameOfNotFoundResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFoundResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFoundResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotFoundResponseCode as json.
func (s NotFoundResponseCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NotFoundResponseCode from json.
func (s *NotFoundResponseCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFoundResponseCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NotFoundResponseCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotFoundResponseCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFoundResponseCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BeschlussfassungAbstimmungsart as json.
func (o OptBeschlussfassungAbstimmungsart) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BeschlussfassungAbstimmungsart from json.
func (o *OptBeschlussfassungAbstimmungsart) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBeschlussfassungAbstimmungsart to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBeschlussfassungAbstimmungsart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBeschlussfassungAbstimmungsart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BeschlussfassungMehrheit as json.
func (o OptBeschlussfassungMehrheit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BeschlussfassungMehrheit from json.
func (o *OptBeschlussfassungMehrheit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBeschlussfassungMehrheit to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBeschlussfassungMehrheit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBeschlussfassungMehrheit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Bundesland as json.
func (o OptBundesland) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Bundesland from json.
func (o *OptBundesland) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBundesland to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBundesland) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBundesland) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDate) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDate) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDate to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDate)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDate)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Quadrant as json.
func (o OptQuadrant) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Quadrant from json.
func (o *OptQuadrant) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQuadrant to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQuadrant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQuadrant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UrheberRolle as json.
func (o OptUrheberRolle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UrheberRolle from json.
func (o *OptUrheberRolle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUrheberRolle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUrheberRolle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUrheberRolle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Zuordnung as json.
func (o OptZuordnung) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Zuordnung from json.
func (o *OptZuordnung) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptZuordnung to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptZuordnung) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptZuordnung) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Person) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Person) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("nachname")
		e.Str(s.Nachname)
	}
	{
		e.FieldStart("vorname")
		e.Str(s.Vorname)
	}
	{
		if s.Namenszusatz.Set {
			e.FieldStart("namenszusatz")
			s.Namenszusatz.Encode(e)
		}
	}
	{
		e.FieldStart("typ")
		e.Str(s.Typ)
	}
	{
		if s.Wahlperiode.Set {
			e.FieldStart("wahlperiode")
			s.Wahlperiode.Encode(e)
		}
	}
	{
		if s.Basisdatum.Set {
			e.FieldStart("basisdatum")
			s.Basisdatum.Encode(e, json.EncodeDate)
		}
	}
	{
		if s.Datum.Set {
			e.FieldStart("datum")
			s.Datum.Encode(e, json.EncodeDate)
		}
	}
	{
		e.FieldStart("aktualisiert")
		json.EncodeDateTime(e, s.Aktualisiert)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		if s.PersonRoles != nil {
			e.FieldStart("person_roles")
			e.ArrStart()
			for _, elem := range s.PersonRoles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPerson = [11]string{
	0:  "id",
	1:  "nachname",
	2:  "vorname",
	3:  "namenszusatz",
	4:  "typ",
	5:  "wahlperiode",
	6:  "basisdatum",
	7:  "datum",
	8:  "aktualisiert",
	9:  "titel",
	10: "person_roles",
}

// Decode decodes Person from json.
func (s *Person) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Person to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "nachname":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Nachname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nachname\"")
			}
		case "vorname":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Vorname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorname\"")
			}
		case "namenszusatz":
			if err := func() error {
				s.Namenszusatz.Reset()
				if err := s.Namenszusatz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namenszusatz\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Typ = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "wahlperiode":
			if err := func() error {
				s.Wahlperiode.Reset()
				if err := s.Wahlperiode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode\"")
			}
		case "basisdatum":
			if err := func() error {
				s.Basisdatum.Reset()
				if err := s.Basisdatum.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basisdatum\"")
			}
		case "datum":
			if err := func() error {
				s.Datum.Reset()
				if err := s.Datum.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "aktualisiert":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Aktualisiert = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktualisiert\"")
			}
		case "titel":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "person_roles":
			if err := func() error {
				s.PersonRoles = make([]PersonRole, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PersonRole
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PersonRoles = append(s.PersonRoles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"person_roles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Person")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00010111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPerson) {
					name = jsonFieldsNameOfPerson[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Person) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Person) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numFound")
		e.Int32(s.NumFound)
	}
	{
		e.FieldStart("cursor")
		e.Str(s.Cursor)
	}
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPersonListResponse = [3]string{
	0: "numFound",
	1: "cursor",
	2: "documents",
}

// Decode decodes PersonListResponse from json.
func (s *PersonListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numFound\"")
			}
		case "cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cursor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "documents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Documents = make([]Person, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Person
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonListResponse) {
					name = jsonFieldsNameOfPersonListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PersonRole) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PersonRole) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("funktion")
		e.Str(s.Funktion)
	}
	{
		if s.Funktionszusatz.Set {
			e.FieldStart("funktionszusatz")
			s.Funktionszusatz.Encode(e)
		}
	}
	{
		if s.Fraktion.Set {
			e.FieldStart("fraktion")
			s.Fraktion.Encode(e)
		}
	}
	{
		e.FieldStart("nachname")
		e.Str(s.Nachname)
	}
	{
		e.FieldStart("vorname")
		e.Str(s.Vorname)
	}
	{
		if s.Namenszusatz.Set {
			e.FieldStart("namenszusatz")
			s.Namenszusatz.Encode(e)
		}
	}
	{
		if s.WahlperiodeNummer != nil {
			e.FieldStart("wahlperiode_nummer")
			e.ArrStart()
			for _, elem := range s.WahlperiodeNummer {
				e.Int32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Wahlkreiszusatz.Set {
			e.FieldStart("wahlkreiszusatz")
			s.Wahlkreiszusatz.Encode(e)
		}
	}
	{
		if s.RessortTitel.Set {
			e.FieldStart("ressort_titel")
			s.RessortTitel.Encode(e)
		}
	}
	{
		if s.Bundesland.Set {
			e.FieldStart("bundesland")
			s.Bundesland.Encode(e)
		}
	}
}

var jsonFieldsNameOfPersonRole = [10]string{
	0: "funktion",
	1: "funktionszusatz",
	2: "fraktion",
	3: "nachname",
	4: "vorname",
	5: "namenszusatz",
	6: "wahlperiode_nummer",
	7: "wahlkreiszusatz",
	8: "ressort_titel",
	9: "bundesland",
}

// Decode decodes PersonRole from json.
func (s *PersonRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PersonRole to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "funktion":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Funktion = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"funktion\"")
			}
		case "funktionszusatz":
			if err := func() error {
				s.Funktionszusatz.Reset()
				if err := s.Funktionszusatz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"funktionszusatz\"")
			}
		case "fraktion":
			if err := func() error {
				s.Fraktion.Reset()
				if err := s.Fraktion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fraktion\"")
			}
		case "nachname":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Nachname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nachname\"")
			}
		case "vorname":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Vorname = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorname\"")
			}
		case "namenszusatz":
			if err := func() error {
				s.Namenszusatz.Reset()
				if err := s.Namenszusatz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namenszusatz\"")
			}
		case "wahlperiode_nummer":
			if err := func() error {
				s.WahlperiodeNummer = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.WahlperiodeNummer = append(s.WahlperiodeNummer, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode_nummer\"")
			}
		case "wahlkreiszusatz":
			if err := func() error {
				s.Wahlkreiszusatz.Reset()
				if err := s.Wahlkreiszusatz.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlkreiszusatz\"")
			}
		case "ressort_titel":
			if err := func() error {
				s.RessortTitel.Reset()
				if err := s.RessortTitel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ressort_titel\"")
			}
		case "bundesland":
			if err := func() error {
				s.Bundesland.Reset()
				if err := s.Bundesland.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bundesland\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PersonRole")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00011001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPersonRole) {
					name = jsonFieldsNameOfPersonRole[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PersonRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PersonRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Plenarprotokoll) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Plenarprotokoll) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("dokumentart")
		s.Dokumentart.Encode(e)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
	{
		e.FieldStart("dokumentnummer")
		e.Str(s.Dokumentnummer)
	}
	{
		if s.Wahlperiode.Set {
			e.FieldStart("wahlperiode")
			s.Wahlperiode.Encode(e)
		}
	}
	{
		e.FieldStart("herausgeber")
		s.Herausgeber.Encode(e)
	}
	{
		e.FieldStart("datum")
		json.EncodeDate(e, s.Datum)
	}
	{
		e.FieldStart("aktualisiert")
		json.EncodeDateTime(e, s.Aktualisiert)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		e.FieldStart("fundstelle")
		s.Fundstelle.Encode(e)
	}
	{
		if s.PdfHash.Set {
			e.FieldStart("pdf_hash")
			s.PdfHash.Encode(e)
		}
	}
	{
		if s.Vorgangsbezug != nil {
			e.FieldStart("vorgangsbezug")
			e.ArrStart()
			for _, elem := range s.Vorgangsbezug {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("vorgangsbezug_anzahl")
		e.Int32(s.VorgangsbezugAnzahl)
	}
	{
		if s.Sitzungsbemerkung.Set {
			e.FieldStart("sitzungsbemerkung")
			s.Sitzungsbemerkung.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlenarprotokoll = [14]string{
	0:  "id",
	1:  "dokumentart",
	2:  "typ",
	3:  "dokumentnummer",
	4:  "wahlperiode",
	5:  "herausgeber",
	6:  "datum",
	7:  "aktualisiert",
	8:  "titel",
	9:  "fundstelle",
	10: "pdf_hash",
	11: "vorgangsbezug",
	12: "vorgangsbezug_anzahl",
	13: "sitzungsbemerkung",
}

// Decode decodes Plenarprotokoll from json.
func (s *Plenarprotokoll) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Plenarprotokoll to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dokumentart":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Dokumentart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentart\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "dokumentnummer":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Dokumentnummer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentnummer\"")
			}
		case "wahlperiode":
			if err := func() error {
				s.Wahlperiode.Reset()
				if err := s.Wahlperiode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode\"")
			}
		case "herausgeber":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Herausgeber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"herausgeber\"")
			}
		case "datum":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Datum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "aktualisiert":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Aktualisiert = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktualisiert\"")
			}
		case "titel":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "fundstelle":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fundstelle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundstelle\"")
			}
		case "pdf_hash":
			if err := func() error {
				s.PdfHash.Reset()
				if err := s.PdfHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdf_hash\"")
			}
		case "vorgangsbezug":
			if err := func() error {
				s.Vorgangsbezug = make([]Vorgangsbezug, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vorgangsbezug
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Vorgangsbezug = append(s.Vorgangsbezug, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug\"")
			}
		case "vorgangsbezug_anzahl":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.VorgangsbezugAnzahl = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug_anzahl\"")
			}
		case "sitzungsbemerkung":
			if err := func() error {
				s.Sitzungsbemerkung.Reset()
				if err := s.Sitzungsbemerkung.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sitzungsbemerkung\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Plenarprotokoll")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlenarprotokoll) {
					name = jsonFieldsNameOfPlenarprotokoll[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Plenarprotokoll) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Plenarprotokoll) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlenarprotokollDokumentart as json.
func (s PlenarprotokollDokumentart) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlenarprotokollDokumentart from json.
func (s *PlenarprotokollDokumentart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlenarprotokollDokumentart to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlenarprotokollDokumentart(v) {
	case PlenarprotokollDokumentartPlenarprotokoll:
		*s = PlenarprotokollDokumentartPlenarprotokoll
	default:
		*s = PlenarprotokollDokumentart(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlenarprotokollDokumentart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlenarprotokollDokumentart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlenarprotokollListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlenarprotokollListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numFound")
		e.Int32(s.NumFound)
	}
	{
		e.FieldStart("cursor")
		e.Str(s.Cursor)
	}
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPlenarprotokollListResponse = [3]string{
	0: "numFound",
	1: "cursor",
	2: "documents",
}

// Decode decodes PlenarprotokollListResponse from json.
func (s *PlenarprotokollListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlenarprotokollListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numFound\"")
			}
		case "cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cursor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "documents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Documents = make([]Plenarprotokoll, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Plenarprotokoll
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlenarprotokollListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlenarprotokollListResponse) {
					name = jsonFieldsNameOfPlenarprotokollListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlenarprotokollListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlenarprotokollListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlenarprotokollText) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlenarprotokollText) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("dokumentart")
		s.Dokumentart.Encode(e)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
	{
		e.FieldStart("dokumentnummer")
		e.Str(s.Dokumentnummer)
	}
	{
		if s.Wahlperiode.Set {
			e.FieldStart("wahlperiode")
			s.Wahlperiode.Encode(e)
		}
	}
	{
		e.FieldStart("herausgeber")
		s.Herausgeber.Encode(e)
	}
	{
		e.FieldStart("datum")
		json.EncodeDate(e, s.Datum)
	}
	{
		e.FieldStart("aktualisiert")
		json.EncodeDateTime(e, s.Aktualisiert)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		e.FieldStart("fundstelle")
		s.Fundstelle.Encode(e)
	}
	{
		if s.PdfHash.Set {
			e.FieldStart("pdf_hash")
			s.PdfHash.Encode(e)
		}
	}
	{
		if s.Vorgangsbezug != nil {
			e.FieldStart("vorgangsbezug")
			e.ArrStart()
			for _, elem := range s.Vorgangsbezug {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("vorgangsbezug_anzahl")
		e.Int32(s.VorgangsbezugAnzahl)
	}
	{
		if s.Sitzungsbemerkung.Set {
			e.FieldStart("sitzungsbemerkung")
			s.Sitzungsbemerkung.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlenarprotokollText = [15]string{
	0:  "id",
	1:  "dokumentart",
	2:  "typ",
	3:  "dokumentnummer",
	4:  "wahlperiode",
	5:  "herausgeber",
	6:  "datum",
	7:  "aktualisiert",
	8:  "titel",
	9:  "fundstelle",
	10: "pdf_hash",
	11: "vorgangsbezug",
	12: "vorgangsbezug_anzahl",
	13: "sitzungsbemerkung",
	14: "text",
}

// Decode decodes PlenarprotokollText from json.
func (s *PlenarprotokollText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlenarprotokollText to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dokumentart":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Dokumentart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentart\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "dokumentnummer":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Dokumentnummer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentnummer\"")
			}
		case "wahlperiode":
			if err := func() error {
				s.Wahlperiode.Reset()
				if err := s.Wahlperiode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode\"")
			}
		case "herausgeber":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Herausgeber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"herausgeber\"")
			}
		case "datum":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Datum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "aktualisiert":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Aktualisiert = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktualisiert\"")
			}
		case "titel":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "fundstelle":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fundstelle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundstelle\"")
			}
		case "pdf_hash":
			if err := func() error {
				s.PdfHash.Reset()
				if err := s.PdfHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdf_hash\"")
			}
		case "vorgangsbezug":
			if err := func() error {
				s.Vorgangsbezug = make([]Vorgangsbezug, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vorgangsbezug
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Vorgangsbezug = append(s.Vorgangsbezug, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug\"")
			}
		case "vorgangsbezug_anzahl":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.VorgangsbezugAnzahl = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsbezug_anzahl\"")
			}
		case "sitzungsbemerkung":
			if err := func() error {
				s.Sitzungsbemerkung.Reset()
				if err := s.Sitzungsbemerkung.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sitzungsbemerkung\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlenarprotokollText")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlenarprotokollText) {
					name = jsonFieldsNameOfPlenarprotokollText[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlenarprotokollText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlenarprotokollText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlenarprotokollTextDokumentart as json.
func (s PlenarprotokollTextDokumentart) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlenarprotokollTextDokumentart from json.
func (s *PlenarprotokollTextDokumentart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlenarprotokollTextDokumentart to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlenarprotokollTextDokumentart(v) {
	case PlenarprotokollTextDokumentartPlenarprotokoll:
		*s = PlenarprotokollTextDokumentartPlenarprotokoll
	default:
		*s = PlenarprotokollTextDokumentart(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlenarprotokollTextDokumentart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlenarprotokollTextDokumentart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PlenarprotokollTextListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PlenarprotokollTextListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numFound")
		e.Int32(s.NumFound)
	}
	{
		e.FieldStart("cursor")
		e.Str(s.Cursor)
	}
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPlenarprotokollTextListResponse = [3]string{
	0: "numFound",
	1: "cursor",
	2: "documents",
}

// Decode decodes PlenarprotokollTextListResponse from json.
func (s *PlenarprotokollTextListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlenarprotokollTextListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numFound\"")
			}
		case "cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cursor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "documents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Documents = make([]PlenarprotokollText, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PlenarprotokollText
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PlenarprotokollTextListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPlenarprotokollTextListResponse) {
					name = jsonFieldsNameOfPlenarprotokollTextListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PlenarprotokollTextListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlenarprotokollTextListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlenarprotokollTextTyp as json.
func (s PlenarprotokollTextTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlenarprotokollTextTyp from json.
func (s *PlenarprotokollTextTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlenarprotokollTextTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlenarprotokollTextTyp(v) {
	case PlenarprotokollTextTypDokument:
		*s = PlenarprotokollTextTypDokument
	default:
		*s = PlenarprotokollTextTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlenarprotokollTextTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlenarprotokollTextTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlenarprotokollTyp as json.
func (s PlenarprotokollTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlenarprotokollTyp from json.
func (s *PlenarprotokollTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlenarprotokollTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlenarprotokollTyp(v) {
	case PlenarprotokollTypDokument:
		*s = PlenarprotokollTypDokument
	default:
		*s = PlenarprotokollTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlenarprotokollTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlenarprotokollTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Quadrant as json.
func (s Quadrant) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Quadrant from json.
func (s *Quadrant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Quadrant to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Quadrant(v) {
	case QuadrantA:
		*s = QuadrantA
	case QuadrantB:
		*s = QuadrantB
	case QuadrantC:
		*s = QuadrantC
	case QuadrantD:
		*s = QuadrantD
	default:
		*s = Quadrant(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Quadrant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Quadrant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Ressort) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Ressort) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("federfuehrend")
		e.Bool(s.Federfuehrend)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
}

var jsonFieldsNameOfRessort = [2]string{
	0: "federfuehrend",
	1: "titel",
}

// Decode decodes Ressort from json.
func (s *Ressort) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Ressort to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "federfuehrend":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Federfuehrend = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"federfuehrend\"")
			}
		case "titel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Ressort")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRessort) {
					name = jsonFieldsNameOfRessort[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Ressort) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Ressort) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Ueberweisung) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Ueberweisung) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ausschuss")
		e.Str(s.Ausschuss)
	}
	{
		e.FieldStart("ausschuss_kuerzel")
		e.Str(s.AusschussKuerzel)
	}
	{
		e.FieldStart("federfuehrung")
		e.Bool(s.Federfuehrung)
	}
	{
		if s.Ueberweisungsart.Set {
			e.FieldStart("ueberweisungsart")
			s.Ueberweisungsart.Encode(e)
		}
	}
}

var jsonFieldsNameOfUeberweisung = [4]string{
	0: "ausschuss",
	1: "ausschuss_kuerzel",
	2: "federfuehrung",
	3: "ueberweisungsart",
}

// Decode decodes Ueberweisung from json.
func (s *Ueberweisung) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Ueberweisung to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ausschuss":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ausschuss = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ausschuss\"")
			}
		case "ausschuss_kuerzel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AusschussKuerzel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ausschuss_kuerzel\"")
			}
		case "federfuehrung":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Federfuehrung = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"federfuehrung\"")
			}
		case "ueberweisungsart":
			if err := func() error {
				s.Ueberweisungsart.Reset()
				if err := s.Ueberweisungsart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ueberweisungsart\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Ueberweisung")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUeberweisung) {
					name = jsonFieldsNameOfUeberweisung[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Ueberweisung) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Ueberweisung) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnauthorizedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnauthorizedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		s.Code.Encode(e)
	}
	{
		e.FieldStart("message")
		s.Message.Encode(e)
	}
}

var jsonFieldsNameOfUnauthorizedResponse = [2]string{
	0: "code",
	1: "message",
}

// Decode decodes UnauthorizedResponse from json.
func (s *UnauthorizedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnauthorizedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnauthorizedResponse) {
					name = jsonFieldsNameOfUnauthorizedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnauthorizedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnauthorizedResponseCode as json.
func (s UnauthorizedResponseCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes UnauthorizedResponseCode from json.
func (s *UnauthorizedResponseCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedResponseCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = UnauthorizedResponseCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnauthorizedResponseCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedResponseCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnauthorizedResponseMessage as json.
func (s UnauthorizedResponseMessage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UnauthorizedResponseMessage from json.
func (s *UnauthorizedResponseMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedResponseMessage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UnauthorizedResponseMessage(v) {
	case UnauthorizedResponseMessageAnAPIKeyIsRequiredToAccessThisServicePleaseReferToHTTPSDipBundestagDeBerDipHilfeAPIHowToApplyForAKeyMisuseOfThisServiceMayLeadToBlockingYourRequests:
		*s = UnauthorizedResponseMessageAnAPIKeyIsRequiredToAccessThisServicePleaseReferToHTTPSDipBundestagDeBerDipHilfeAPIHowToApplyForAKeyMisuseOfThisServiceMayLeadToBlockingYourRequests
	default:
		*s = UnauthorizedResponseMessage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnauthorizedResponseMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedResponseMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Urheber) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Urheber) encodeFields(e *jx.Encoder) {
	{
		if s.Einbringer.Set {
			e.FieldStart("einbringer")
			s.Einbringer.Encode(e)
		}
	}
	{
		e.FieldStart("bezeichnung")
		e.Str(s.Bezeichnung)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		if s.Rolle.Set {
			e.FieldStart("rolle")
			s.Rolle.Encode(e)
		}
	}
}

var jsonFieldsNameOfUrheber = [4]string{
	0: "einbringer",
	1: "bezeichnung",
	2: "titel",
	3: "rolle",
}

// Decode decodes Urheber from json.
func (s *Urheber) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Urheber to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "einbringer":
			if err := func() error {
				s.Einbringer.Reset()
				if err := s.Einbringer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"einbringer\"")
			}
		case "bezeichnung":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Bezeichnung = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bezeichnung\"")
			}
		case "titel":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "rolle":
			if err := func() error {
				s.Rolle.Reset()
				if err := s.Rolle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rolle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Urheber")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUrheber) {
					name = jsonFieldsNameOfUrheber[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Urheber) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Urheber) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UrheberRolle as json.
func (s UrheberRolle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UrheberRolle from json.
func (s *UrheberRolle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UrheberRolle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UrheberRolle(v) {
	case UrheberRolleB:
		*s = UrheberRolleB
	case UrheberRolleU:
		*s = UrheberRolleU
	default:
		*s = UrheberRolle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UrheberRolle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UrheberRolle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Verkuendung) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Verkuendung) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("jahrgang")
		e.Str(s.Jahrgang)
	}
	{
		if s.Heftnummer.Set {
			e.FieldStart("heftnummer")
			s.Heftnummer.Encode(e)
		}
	}
	{
		e.FieldStart("seite")
		e.Str(s.Seite)
	}
	{
		e.FieldStart("ausfertigungsdatum")
		json.EncodeDate(e, s.Ausfertigungsdatum)
	}
	{
		e.FieldStart("verkuendungsdatum")
		json.EncodeDate(e, s.Verkuendungsdatum)
	}
	{
		if s.RubrikNr.Set {
			e.FieldStart("rubrik_nr")
			s.RubrikNr.Encode(e)
		}
	}
	{
		e.FieldStart("einleitungstext")
		e.Str(s.Einleitungstext)
	}
	{
		if s.VerkuendungsblattBezeichnung.Set {
			e.FieldStart("verkuendungsblatt_bezeichnung")
			s.VerkuendungsblattBezeichnung.Encode(e)
		}
	}
	{
		if s.VerkuendungsblattKuerzel.Set {
			e.FieldStart("verkuendungsblatt_kuerzel")
			s.VerkuendungsblattKuerzel.Encode(e)
		}
	}
	{
		e.FieldStart("fundstelle")
		e.Str(s.Fundstelle)
	}
	{
		if s.PdfURL.Set {
			e.FieldStart("pdf_url")
			s.PdfURL.Encode(e)
		}
	}
	{
		if s.Titel.Set {
			e.FieldStart("titel")
			s.Titel.Encode(e)
		}
	}
}

var jsonFieldsNameOfVerkuendung = [12]string{
	0:  "jahrgang",
	1:  "heftnummer",
	2:  "seite",
	3:  "ausfertigungsdatum",
	4:  "verkuendungsdatum",
	5:  "rubrik_nr",
	6:  "einleitungstext",
	7:  "verkuendungsblatt_bezeichnung",
	8:  "verkuendungsblatt_kuerzel",
	9:  "fundstelle",
	10: "pdf_url",
	11: "titel",
}

// Decode decodes Verkuendung from json.
func (s *Verkuendung) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Verkuendung to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "jahrgang":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Jahrgang = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jahrgang\"")
			}
		case "heftnummer":
			if err := func() error {
				s.Heftnummer.Reset()
				if err := s.Heftnummer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heftnummer\"")
			}
		case "seite":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Seite = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"seite\"")
			}
		case "ausfertigungsdatum":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Ausfertigungsdatum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ausfertigungsdatum\"")
			}
		case "verkuendungsdatum":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Verkuendungsdatum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verkuendungsdatum\"")
			}
		case "rubrik_nr":
			if err := func() error {
				s.RubrikNr.Reset()
				if err := s.RubrikNr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rubrik_nr\"")
			}
		case "einleitungstext":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Einleitungstext = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"einleitungstext\"")
			}
		case "verkuendungsblatt_bezeichnung":
			if err := func() error {
				s.VerkuendungsblattBezeichnung.Reset()
				if err := s.VerkuendungsblattBezeichnung.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verkuendungsblatt_bezeichnung\"")
			}
		case "verkuendungsblatt_kuerzel":
			if err := func() error {
				s.VerkuendungsblattKuerzel.Reset()
				if err := s.VerkuendungsblattKuerzel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verkuendungsblatt_kuerzel\"")
			}
		case "fundstelle":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Fundstelle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundstelle\"")
			}
		case "pdf_url":
			if err := func() error {
				s.PdfURL.Reset()
				if err := s.PdfURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pdf_url\"")
			}
		case "titel":
			if err := func() error {
				s.Titel.Reset()
				if err := s.Titel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Verkuendung")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01011101,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerkuendung) {
					name = jsonFieldsNameOfVerkuendung[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Verkuendung) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Verkuendung) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vorgang) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vorgang) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
	{
		if s.Beratungsstand.Set {
			e.FieldStart("beratungsstand")
			s.Beratungsstand.Encode(e)
		}
	}
	{
		e.FieldStart("vorgangstyp")
		e.Str(s.Vorgangstyp)
	}
	{
		e.FieldStart("wahlperiode")
		e.Int32(s.Wahlperiode)
	}
	{
		if s.Initiative != nil {
			e.FieldStart("initiative")
			e.ArrStart()
			for _, elem := range s.Initiative {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Datum.Set {
			e.FieldStart("datum")
			s.Datum.Encode(e, json.EncodeDate)
		}
	}
	{
		e.FieldStart("aktualisiert")
		json.EncodeDateTime(e, s.Aktualisiert)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		if s.Abstract.Set {
			e.FieldStart("abstract")
			s.Abstract.Encode(e)
		}
	}
	{
		if s.Sachgebiet != nil {
			e.FieldStart("sachgebiet")
			e.ArrStart()
			for _, elem := range s.Sachgebiet {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Deskriptor != nil {
			e.FieldStart("deskriptor")
			e.ArrStart()
			for _, elem := range s.Deskriptor {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Gesta.Set {
			e.FieldStart("gesta")
			s.Gesta.Encode(e)
		}
	}
	{
		if s.Zustimmungsbeduerftigkeit != nil {
			e.FieldStart("zustimmungsbeduerftigkeit")
			e.ArrStart()
			for _, elem := range s.Zustimmungsbeduerftigkeit {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Kom.Set {
			e.FieldStart("kom")
			s.Kom.Encode(e)
		}
	}
	{
		if s.Ratsdok.Set {
			e.FieldStart("ratsdok")
			s.Ratsdok.Encode(e)
		}
	}
	{
		if s.Verkuendung != nil {
			e.FieldStart("verkuendung")
			e.ArrStart()
			for _, elem := range s.Verkuendung {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Inkrafttreten != nil {
			e.FieldStart("inkrafttreten")
			e.ArrStart()
			for _, elem := range s.Inkrafttreten {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Archiv.Set {
			e.FieldStart("archiv")
			s.Archiv.Encode(e)
		}
	}
	{
		if s.Mitteilung.Set {
			e.FieldStart("mitteilung")
			s.Mitteilung.Encode(e)
		}
	}
	{
		if s.VorgangVerlinkung != nil {
			e.FieldStart("vorgang_verlinkung")
			e.ArrStart()
			for _, elem := range s.VorgangVerlinkung {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Sek.Set {
			e.FieldStart("sek")
			s.Sek.Encode(e)
		}
	}
}

var jsonFieldsNameOfVorgang = [22]string{
	0:  "id",
	1:  "typ",
	2:  "beratungsstand",
	3:  "vorgangstyp",
	4:  "wahlperiode",
	5:  "initiative",
	6:  "datum",
	7:  "aktualisiert",
	8:  "titel",
	9:  "abstract",
	10: "sachgebiet",
	11: "deskriptor",
	12: "gesta",
	13: "zustimmungsbeduerftigkeit",
	14: "kom",
	15: "ratsdok",
	16: "verkuendung",
	17: "inkrafttreten",
	18: "archiv",
	19: "mitteilung",
	20: "vorgang_verlinkung",
	21: "sek",
}

// Decode decodes Vorgang from json.
func (s *Vorgang) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vorgang to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "beratungsstand":
			if err := func() error {
				s.Beratungsstand.Reset()
				if err := s.Beratungsstand.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beratungsstand\"")
			}
		case "vorgangstyp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Vorgangstyp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangstyp\"")
			}
		case "wahlperiode":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.Wahlperiode = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode\"")
			}
		case "initiative":
			if err := func() error {
				s.Initiative = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Initiative = append(s.Initiative, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"initiative\"")
			}
		case "datum":
			if err := func() error {
				s.Datum.Reset()
				if err := s.Datum.Decode(d, json.DecodeDate); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "aktualisiert":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Aktualisiert = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktualisiert\"")
			}
		case "titel":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "abstract":
			if err := func() error {
				s.Abstract.Reset()
				if err := s.Abstract.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abstract\"")
			}
		case "sachgebiet":
			if err := func() error {
				s.Sachgebiet = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Sachgebiet = append(s.Sachgebiet, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sachgebiet\"")
			}
		case "deskriptor":
			if err := func() error {
				s.Deskriptor = make([]VorgangDeskriptor, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VorgangDeskriptor
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Deskriptor = append(s.Deskriptor, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deskriptor\"")
			}
		case "gesta":
			if err := func() error {
				s.Gesta.Reset()
				if err := s.Gesta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gesta\"")
			}
		case "zustimmungsbeduerftigkeit":
			if err := func() error {
				s.Zustimmungsbeduerftigkeit = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Zustimmungsbeduerftigkeit = append(s.Zustimmungsbeduerftigkeit, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zustimmungsbeduerftigkeit\"")
			}
		case "kom":
			if err := func() error {
				s.Kom.Reset()
				if err := s.Kom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kom\"")
			}
		case "ratsdok":
			if err := func() error {
				s.Ratsdok.Reset()
				if err := s.Ratsdok.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratsdok\"")
			}
		case "verkuendung":
			if err := func() error {
				s.Verkuendung = make([]Verkuendung, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Verkuendung
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Verkuendung = append(s.Verkuendung, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verkuendung\"")
			}
		case "inkrafttreten":
			if err := func() error {
				s.Inkrafttreten = make([]Inkrafttreten, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Inkrafttreten
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inkrafttreten = append(s.Inkrafttreten, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inkrafttreten\"")
			}
		case "archiv":
			if err := func() error {
				s.Archiv.Reset()
				if err := s.Archiv.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archiv\"")
			}
		case "mitteilung":
			if err := func() error {
				s.Mitteilung.Reset()
				if err := s.Mitteilung.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mitteilung\"")
			}
		case "vorgang_verlinkung":
			if err := func() error {
				s.VorgangVerlinkung = make([]VorgangVerlinkung, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VorgangVerlinkung
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.VorgangVerlinkung = append(s.VorgangVerlinkung, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgang_verlinkung\"")
			}
		case "sek":
			if err := func() error {
				s.Sek.Reset()
				if err := s.Sek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sek\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vorgang")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b10011011,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVorgang) {
					name = jsonFieldsNameOfVorgang[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vorgang) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vorgang) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VorgangDeskriptor) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VorgangDeskriptor) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
	{
		e.FieldStart("fundstelle")
		e.Bool(s.Fundstelle)
	}
}

var jsonFieldsNameOfVorgangDeskriptor = [3]string{
	0: "name",
	1: "typ",
	2: "fundstelle",
}

// Decode decodes VorgangDeskriptor from json.
func (s *VorgangDeskriptor) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VorgangDeskriptor to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "fundstelle":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Fundstelle = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundstelle\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VorgangDeskriptor")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVorgangDeskriptor) {
					name = jsonFieldsNameOfVorgangDeskriptor[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VorgangDeskriptor) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VorgangDeskriptor) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VorgangDeskriptorTyp as json.
func (s VorgangDeskriptorTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VorgangDeskriptorTyp from json.
func (s *VorgangDeskriptorTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VorgangDeskriptorTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VorgangDeskriptorTyp(v) {
	case VorgangDeskriptorTypFreierDeskriptor:
		*s = VorgangDeskriptorTypFreierDeskriptor
	case VorgangDeskriptorTypGeographBegriffe:
		*s = VorgangDeskriptorTypGeographBegriffe
	case VorgangDeskriptorTypInstitutionen:
		*s = VorgangDeskriptorTypInstitutionen
	case VorgangDeskriptorTypPersonen:
		*s = VorgangDeskriptorTypPersonen
	case VorgangDeskriptorTypRechtsmaterialien:
		*s = VorgangDeskriptorTypRechtsmaterialien
	case VorgangDeskriptorTypSachbegriffe:
		*s = VorgangDeskriptorTypSachbegriffe
	default:
		*s = VorgangDeskriptorTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VorgangDeskriptorTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VorgangDeskriptorTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VorgangListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VorgangListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numFound")
		e.Int32(s.NumFound)
	}
	{
		e.FieldStart("cursor")
		e.Str(s.Cursor)
	}
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVorgangListResponse = [3]string{
	0: "numFound",
	1: "cursor",
	2: "documents",
}

// Decode decodes VorgangListResponse from json.
func (s *VorgangListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VorgangListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numFound\"")
			}
		case "cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cursor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "documents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Documents = make([]Vorgang, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vorgang
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VorgangListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVorgangListResponse) {
					name = jsonFieldsNameOfVorgangListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VorgangListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VorgangListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VorgangTyp as json.
func (s VorgangTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VorgangTyp from json.
func (s *VorgangTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VorgangTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VorgangTyp(v) {
	case VorgangTypVorgang:
		*s = VorgangTypVorgang
	default:
		*s = VorgangTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VorgangTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VorgangTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VorgangVerlinkung) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VorgangVerlinkung) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("verweisung")
		e.Str(s.Verweisung)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		e.FieldStart("wahlperiode")
		e.Int32(s.Wahlperiode)
	}
	{
		if s.Gesta.Set {
			e.FieldStart("gesta")
			s.Gesta.Encode(e)
		}
	}
}

var jsonFieldsNameOfVorgangVerlinkung = [5]string{
	0: "id",
	1: "verweisung",
	2: "titel",
	3: "wahlperiode",
	4: "gesta",
}

// Decode decodes VorgangVerlinkung from json.
func (s *VorgangVerlinkung) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VorgangVerlinkung to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "verweisung":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Verweisung = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verweisung\"")
			}
		case "titel":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "wahlperiode":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int32()
				s.Wahlperiode = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wahlperiode\"")
			}
		case "gesta":
			if err := func() error {
				s.Gesta.Reset()
				if err := s.Gesta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gesta\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VorgangVerlinkung")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVorgangVerlinkung) {
					name = jsonFieldsNameOfVorgangVerlinkung[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VorgangVerlinkung) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VorgangVerlinkung) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vorgangsbezug) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vorgangsbezug) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		e.FieldStart("vorgangstyp")
		e.Str(s.Vorgangstyp)
	}
}

var jsonFieldsNameOfVorgangsbezug = [3]string{
	0: "id",
	1: "titel",
	2: "vorgangstyp",
}

// Decode decodes Vorgangsbezug from json.
func (s *Vorgangsbezug) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vorgangsbezug to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "titel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "vorgangstyp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Vorgangstyp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangstyp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vorgangsbezug")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVorgangsbezug) {
					name = jsonFieldsNameOfVorgangsbezug[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vorgangsbezug) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vorgangsbezug) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vorgangsposition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vorgangsposition) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("vorgangsposition")
		e.Str(s.Vorgangsposition)
	}
	{
		e.FieldStart("zuordnung")
		s.Zuordnung.Encode(e)
	}
	{
		e.FieldStart("gang")
		e.Bool(s.Gang)
	}
	{
		e.FieldStart("fortsetzung")
		e.Bool(s.Fortsetzung)
	}
	{
		e.FieldStart("nachtrag")
		e.Bool(s.Nachtrag)
	}
	{
		e.FieldStart("vorgangstyp")
		e.Str(s.Vorgangstyp)
	}
	{
		e.FieldStart("typ")
		s.Typ.Encode(e)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		e.FieldStart("dokumentart")
		s.Dokumentart.Encode(e)
	}
	{
		e.FieldStart("vorgang_id")
		e.Str(s.VorgangID)
	}
	{
		e.FieldStart("datum")
		json.EncodeDate(e, s.Datum)
	}
	{
		e.FieldStart("aktualisiert")
		json.EncodeDateTime(e, s.Aktualisiert)
	}
	{
		e.FieldStart("fundstelle")
		s.Fundstelle.Encode(e)
	}
	{
		if s.Urheber != nil {
			e.FieldStart("urheber")
			e.ArrStart()
			for _, elem := range s.Urheber {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ueberweisung != nil {
			e.FieldStart("ueberweisung")
			e.ArrStart()
			for _, elem := range s.Ueberweisung {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AktivitaetAnzeige != nil {
			e.FieldStart("aktivitaet_anzeige")
			e.ArrStart()
			for _, elem := range s.AktivitaetAnzeige {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("aktivitaet_anzahl")
		e.Int32(s.AktivitaetAnzahl)
	}
	{
		if s.Ressort != nil {
			e.FieldStart("ressort")
			e.ArrStart()
			for _, elem := range s.Ressort {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Beschlussfassung != nil {
			e.FieldStart("beschlussfassung")
			e.ArrStart()
			for _, elem := range s.Beschlussfassung {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Ratsdok.Set {
			e.FieldStart("ratsdok")
			s.Ratsdok.Encode(e)
		}
	}
	{
		if s.Kom.Set {
			e.FieldStart("kom")
			s.Kom.Encode(e)
		}
	}
	{
		if s.Sek.Set {
			e.FieldStart("sek")
			s.Sek.Encode(e)
		}
	}
	{
		if s.Mitberaten != nil {
			e.FieldStart("mitberaten")
			e.ArrStart()
			for _, elem := range s.Mitberaten {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Abstract.Set {
			e.FieldStart("abstract")
			s.Abstract.Encode(e)
		}
	}
}

var jsonFieldsNameOfVorgangsposition = [25]string{
	0:  "id",
	1:  "vorgangsposition",
	2:  "zuordnung",
	3:  "gang",
	4:  "fortsetzung",
	5:  "nachtrag",
	6:  "vorgangstyp",
	7:  "typ",
	8:  "titel",
	9:  "dokumentart",
	10: "vorgang_id",
	11: "datum",
	12: "aktualisiert",
	13: "fundstelle",
	14: "urheber",
	15: "ueberweisung",
	16: "aktivitaet_anzeige",
	17: "aktivitaet_anzahl",
	18: "ressort",
	19: "beschlussfassung",
	20: "ratsdok",
	21: "kom",
	22: "sek",
	23: "mitberaten",
	24: "abstract",
}

// Decode decodes Vorgangsposition from json.
func (s *Vorgangsposition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vorgangsposition to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "vorgangsposition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Vorgangsposition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsposition\"")
			}
		case "zuordnung":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Zuordnung.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zuordnung\"")
			}
		case "gang":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Gang = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gang\"")
			}
		case "fortsetzung":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Fortsetzung = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fortsetzung\"")
			}
		case "nachtrag":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Nachtrag = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nachtrag\"")
			}
		case "vorgangstyp":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Vorgangstyp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangstyp\"")
			}
		case "typ":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Typ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"typ\"")
			}
		case "titel":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "dokumentart":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Dokumentart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dokumentart\"")
			}
		case "vorgang_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VorgangID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgang_id\"")
			}
		case "datum":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDate(d)
				s.Datum = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"datum\"")
			}
		case "aktualisiert":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Aktualisiert = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktualisiert\"")
			}
		case "fundstelle":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Fundstelle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fundstelle\"")
			}
		case "urheber":
			if err := func() error {
				s.Urheber = make([]Urheber, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Urheber
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Urheber = append(s.Urheber, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urheber\"")
			}
		case "ueberweisung":
			if err := func() error {
				s.Ueberweisung = make([]Ueberweisung, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Ueberweisung
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ueberweisung = append(s.Ueberweisung, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ueberweisung\"")
			}
		case "aktivitaet_anzeige":
			if err := func() error {
				s.AktivitaetAnzeige = make([]AktivitaetAnzeige, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AktivitaetAnzeige
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AktivitaetAnzeige = append(s.AktivitaetAnzeige, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktivitaet_anzeige\"")
			}
		case "aktivitaet_anzahl":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.AktivitaetAnzahl = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aktivitaet_anzahl\"")
			}
		case "ressort":
			if err := func() error {
				s.Ressort = make([]Ressort, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Ressort
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ressort = append(s.Ressort, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ressort\"")
			}
		case "beschlussfassung":
			if err := func() error {
				s.Beschlussfassung = make([]Beschlussfassung, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Beschlussfassung
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Beschlussfassung = append(s.Beschlussfassung, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"beschlussfassung\"")
			}
		case "ratsdok":
			if err := func() error {
				s.Ratsdok.Reset()
				if err := s.Ratsdok.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ratsdok\"")
			}
		case "kom":
			if err := func() error {
				s.Kom.Reset()
				if err := s.Kom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kom\"")
			}
		case "sek":
			if err := func() error {
				s.Sek.Reset()
				if err := s.Sek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sek\"")
			}
		case "mitberaten":
			if err := func() error {
				s.Mitberaten = make([]Vorgangspositionbezug, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vorgangspositionbezug
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Mitberaten = append(s.Mitberaten, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mitberaten\"")
			}
		case "abstract":
			if err := func() error {
				s.Abstract.Reset()
				if err := s.Abstract.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abstract\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vorgangsposition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b00111111,
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVorgangsposition) {
					name = jsonFieldsNameOfVorgangsposition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vorgangsposition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vorgangsposition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VorgangspositionDokumentart as json.
func (s VorgangspositionDokumentart) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VorgangspositionDokumentart from json.
func (s *VorgangspositionDokumentart) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VorgangspositionDokumentart to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VorgangspositionDokumentart(v) {
	case VorgangspositionDokumentartDrucksache:
		*s = VorgangspositionDokumentartDrucksache
	case VorgangspositionDokumentartPlenarprotokoll:
		*s = VorgangspositionDokumentartPlenarprotokoll
	default:
		*s = VorgangspositionDokumentart(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VorgangspositionDokumentart) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VorgangspositionDokumentart) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VorgangspositionListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VorgangspositionListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("numFound")
		e.Int32(s.NumFound)
	}
	{
		e.FieldStart("cursor")
		e.Str(s.Cursor)
	}
	{
		e.FieldStart("documents")
		e.ArrStart()
		for _, elem := range s.Documents {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVorgangspositionListResponse = [3]string{
	0: "numFound",
	1: "cursor",
	2: "documents",
}

// Decode decodes VorgangspositionListResponse from json.
func (s *VorgangspositionListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VorgangspositionListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "numFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.NumFound = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numFound\"")
			}
		case "cursor":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Cursor = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cursor\"")
			}
		case "documents":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Documents = make([]Vorgangsposition, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Vorgangsposition
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Documents = append(s.Documents, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"documents\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VorgangspositionListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVorgangspositionListResponse) {
					name = jsonFieldsNameOfVorgangspositionListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VorgangspositionListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VorgangspositionListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VorgangspositionTyp as json.
func (s VorgangspositionTyp) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VorgangspositionTyp from json.
func (s *VorgangspositionTyp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VorgangspositionTyp to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VorgangspositionTyp(v) {
	case VorgangspositionTypVorgangsposition:
		*s = VorgangspositionTypVorgangsposition
	default:
		*s = VorgangspositionTyp(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VorgangspositionTyp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VorgangspositionTyp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Vorgangspositionbezug) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Vorgangspositionbezug) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("titel")
		e.Str(s.Titel)
	}
	{
		e.FieldStart("vorgangstyp")
		e.Str(s.Vorgangstyp)
	}
	{
		e.FieldStart("vorgangsposition")
		e.Str(s.Vorgangsposition)
	}
}

var jsonFieldsNameOfVorgangspositionbezug = [4]string{
	0: "id",
	1: "titel",
	2: "vorgangstyp",
	3: "vorgangsposition",
}

// Decode decodes Vorgangspositionbezug from json.
func (s *Vorgangspositionbezug) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Vorgangspositionbezug to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "titel":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Titel = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"titel\"")
			}
		case "vorgangstyp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Vorgangstyp = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangstyp\"")
			}
		case "vorgangsposition":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Vorgangsposition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vorgangsposition\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Vorgangspositionbezug")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVorgangspositionbezug) {
					name = jsonFieldsNameOfVorgangspositionbezug[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Vorgangspositionbezug) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Vorgangspositionbezug) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Zuordnung as json.
func (s Zuordnung) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Zuordnung from json.
func (s *Zuordnung) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Zuordnung to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Zuordnung(v) {
	case ZuordnungBT:
		*s = ZuordnungBT
	case ZuordnungBR:
		*s = ZuordnungBR
	case ZuordnungBV:
		*s = ZuordnungBV
	case ZuordnungEK:
		*s = ZuordnungEK
	default:
		*s = Zuordnung(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Zuordnung) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Zuordnung) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
